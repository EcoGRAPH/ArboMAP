---
title: "ArboMAP: Arbovirus Modeling and Prediction   \nto Forecast Mosquito-Borne Disease Outbreaks"
author: "Summary of Model Outputs (v2.1)   \nJustin K. Davis and Michael C. Wimberly  \n(justinkdavis@ou.edu, mcwimberly@ou.edu)  \nGeography and Environmental Sustainability, University of Oklahoma"
date: "Updated `r format(Sys.time(), '%B %d, %Y')`"
output: pdf_document
---

```{r setup, include=FALSE}
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)
# define some helpful functions
'%!in%' <- function(x,y)!('%in%'(x,y))
round_any = function(x, accuracy, f=round){f(x/accuracy) * accuracy}
options(warn=-1)
```

```{r createfunctions, include=FALSE}
simplifynames <- function(priornames=NULL) {

  # convert to lower case
  priornames <- tolower(priornames)
  
  # remove spaces
  priornames <- gsub(pattern=" ", replacement="", x=priornames, fixed=TRUE)
  
  # remove district and parish
  priornames <- gsub(pattern="county", replacement="", x=priornames, fixed=TRUE)
  priornames <- gsub(pattern="parish", replacement="", x=priornames, fixed=TRUE)

  # return names
  return(priornames)
  
}
```

```{r libraries, include=FALSE}
packages <- c("reshape2", "ggplot2", "gridExtra",
              "lme4","pracma","dplyr","maptools",
              "raster","spdep","mgcv","sp","rgdal",
              "GISTools","data.table","splines","maps",
              "broom","mapproj", "Hmisc", "parallel",
              "rccmisc", "pROC", "ResourceSelection")
for (package in packages) {
    if (!require(package, character.only=T, quietly=T)) {
        install.packages(package, repos = "http://cran.us.r-project.org")
        library(package, character.only=T)
    }
}
```

```{r setoptions, include=FALSE, echo=FALSE}

# operating system
# it's possible we could detect this on our own, but it's simpler for the user to simply specify
ostype <- "windows"
if (!(ostype %in% c("windows", "mac"))) { ostype <- "windows" }

# spline type is either fixed df cubic regression spline or a thin-plate spline
splinetype <- "thinplate"
if (!(splinetype %in% c("fixeddfcr", "thinplate"))) { splinetype <- "thinplate" }

# determine whether relationships evolve over the course of the year
splineevolution <- "notevolving"
if (!(splineevolution %in% c("seasonallyvarying", "notevolving"))) { splineevolution <- "notevolving" }

# model either uses anomalized environmental and human data or uses raw data
anomalization <- "notanomalized"
if (!(anomalization %in% c("notanomalized", "anomalized"))) { anomalization <- "notanomalized" }

# where do we want the outputs?
graphicoutputdir <- ".\\graphical outputs\\"
fullcasematoutputdir <- ".\\case matrix with estimates\\"
mosqmatoutputdir <- ".\\mosquito matrix with estimates\\"
modeloutputdir <- ".\\model output\\"

# where are the human data located?
# example of a file with directories an drive:
humandatafile <- ".\\human case data\\simulated human case data.csv"
#humandatafile <- "C:\\home\\work\\davis\\ArboMAP for Mike on 19-08-13\\human\\19-01-29 - reconciled human WNV.csv"

# what is the date of the last human case we're willing to believe?
# probably, cut this off at the end of last year
# DO NOT use any human cases from the year you're modeling
maxobservedhumandate <- as.Date("2017-12-31", "%Y-%m-%d")

# which week are we producing the graphs for?
weekinquestion <- as.Date("2018-09-15", "%Y-%m-%d")

# where are the weather csv files stored?
weatherpathstr <- ".\\weather data\\"
#weatherpathstr <- "C:\\home\\work\\davis\\ArboMAP for Mike on 19-08-13\\weather\\"

# what is the name of the summary file to be created?
weathersummaryfile <- "weather data summary file.csv"

# which variables do you want to use?
var1name <- "tmeanc"
var2name <- "vpd"

# where are the mosquito test files located?
mosqfile <- ".\\mosquito data\\simulated mosquito tests.csv"
#mosqfile <- "C:\\home\\work\\davis\\ArboMAP for Mike on 19-08-13\\mosquito\\19-01-29 - state testing.csv"

# which district stratification scheme are we using?
stratafile <- ".\\strata\\17-04-20 - classified strata - classic.csv"

# where is the districtshapefile
districtshapefile <- ".\\shapefile\\cb_2014_us_county_5m - in EPSG 5070 - only SD.shp"

# to which two other years do we want to compare the current year's predictions?
compyear1 <- 2012
compyear2 <- 2017

# probably don't want to modify what follows, but you have some options if you're comfortable
# makes sure we round to the previous Sunday, so that this week is included
weekinquestionSun <- weekinquestion - (as.numeric(strftime(weekinquestion, '%u')) %% 7)
weekinquestionSat <- weekinquestionSun + 6
weekinquestionSunstr <- strftime(weekinquestionSun, '%A')
weekinquestionSatstr <- strftime(weekinquestionSat, '%A')

# figure out which year this is and begin all weeks on Sunday
maxmosqyear <- as.numeric(format(weekinquestion, "%Y"))
maxdesiredhumandate <- as.Date(paste(maxmosqyear,
                                     "-12-31",sep=""))
maxdesiredhumandate <- maxdesiredhumandate - (as.numeric(strftime(maxdesiredhumandate, '%u')) %% 7)
maxdesiredhumandatestr <- strftime(maxdesiredhumandate, '%A')

# make sure the max desired human date is no earlier than the week in question
# otherwise, there will be no predictions for the week in question
maxdesiredhumandate <- max(weekinquestionSun+7, maxdesiredhumandate)

# set up lag and regression information
laglen   <- 181
dlagdeg  <- 8

# mac file setup
if (ostype == "mac") {

  # where do we want the outputs?
  graphicoutputdir <- "./graphical outputs/"
  fullcasematoutputdir <- "./case matrix with estimates/"
  mosqmatoutputdir <- "./mosquito matrix with estimates/"
  modeloutputdir <- "./model output/"
  
  # where are the human data located?
  # example of a file with directories an drive:
  humandatafile <- "./human case data/simulated human case data.csv"
  
  # where are the weather csv files stored?
  weatherpathstr <- "./weather data/"
  
  # what is the name of the summary file to be created?
  weathersummaryfile <- "weather data summary file.csv"
  
  # where are the mosquito test files located?
  mosqfile <- "./mosquito data/simulated mosquito tests.csv"
  
  # which district stratification scheme are we using?
  stratafile <- "./strata/17-04-20 - classified strata - classic.csv"
  
  # where is the districtshapefile
  districtshapefile <- "./shapefile/cb_2014_us_county_5m - in EPSG 5070 - only SD.shp"
  
}
```

# Data used for predictions
## Weather data

```{r weatherdataload, include=FALSE, echo=TRUE}
# load the shapefile immediately so that we can get rid of any districts which are not found here
district_shapes <- readShapePoly(districtshapefile)
# simplify name
district_shapes$district <- simplifynames(district_shapes$NAME)
diagnostic_shapefiledistricts <- unique(district_shapes$district)

weathernames <- c("district", "doy", "year", var1name, var2name)

# load and concat files
weatherlist <- list.files(path=weatherpathstr, pattern="(.csv)", recursive=FALSE)
weather <- data.frame()
for (i in 1:length(weatherlist)) {
  
  if (weatherlist[[i]] != weathersummaryfile) {
  
    tempdf <- read.csv(paste(weatherpathstr, weatherlist[[i]], sep="")) 
    # get rid of the variables we aren't using
    tempdf <- tempdf[,weathernames]
    weather <- bind_rows(weather, tempdf)  
    
  }
  
}
weather$date <- as.Date(paste(weather$year,
                              weather$doy,
                              sep="-"),
                        "%Y-%j")

# get rid of duplicated rows
weather$districtdate <- paste(weather$district, weather$date)
weather <- subset(weather, !duplicated(weather$districtdate))

# be certain district is a factor before modeling
weather$district <- factor(weather$district)

# anomalize weather data if requested
if (anomalization == "anomalized") {
  
  for (curcol in c(var1name, var2name)) {
      
    weather$tempvar <- weather[,curcol]
    tempmod <- bam(tempvar ~ district + s(doy, bs="cc", by=district), data=weather, discrete=TRUE)
    weather[,curcol] <- resid(tempmod)
      
  }
 
  weather$tempvar <- NULL
     
}

# plot normals and this year
weather$var1 <- weather[,which(colnames(weather) == var1name)]
weather$var2 <- weather[,which(colnames(weather) == var2name)]

weather <- group_by(weather,
                    doy)
doymet <- dplyr::summarise(weather,
                           med_var1 = quantile(var1, probs=0.50, na.rm=TRUE),
                           med_var2 = quantile(var2, probs=0.50, na.rm=TRUE),
                           max_var1 = max(var1, na.rm=TRUE),
                           max_var2 = max(var2, na.rm=TRUE),
                           min_var1 = min(var1, na.rm=TRUE),
                           min_var2 = min(var2, na.rm=TRUE))
weather <- ungroup(weather)

thisyear <- max(weather$year, na.rm=TRUE)
thisyear <- subset(weather, year == thisyear)
thisyear <- group_by(thisyear, doy)
thisyear <- dplyr::summarize(thisyear,
                             med_var1 = quantile(var1, probs=0.50, na.rm=TRUE),
                             med_var2 = quantile(var2, probs=0.50, na.rm=TRUE),
                             max_var1 = max(var1, na.rm=TRUE),
                             max_var2 = max(var2, na.rm=TRUE),
                             min_var1 = min(var1, na.rm=TRUE),
                             min_var2 = min(var2, na.rm=TRUE))

weather$var1 <- NULL
weather$var2 <- NULL

tempdf <- left_join(doymet, thisyear, by="doy")
```

Weather data from the gridMET data set range from `r min(weather$date, na.rm=TRUE)` to `r max(weather$date, na.rm=TRUE)`. Below are graphs of statewide daily averages of `r var1name` and `r var2name`. Observations for the current year are in red. Black is the medium from all other years, and the grey band indicates the max/min ever observed. If these data were anomalized, then above (below) zero means higher (lower) than average for that day of the year. Otherwise, data are on their original scales.

```{r weatherplots, fig.width=7, fig.height=5, echo=FALSE}
plot1 <- ggplot() + geom_line(data=doymet, aes(x=doy, y=med_var1)) +
  geom_ribbon(data=doymet, aes(x=doy, ymin=min_var1, ymax=max_var1), alpha=0.3) +
  geom_line(data=thisyear, aes(x=doy, y=med_var1), color="red", size=1) +
  xlab("Day of the year") + ylab(var1name) +
  ggtitle(paste(var1name, 
                max(weather$year, na.rm=TRUE),
                sep=" "))
plot2 <- ggplot() + geom_line(data=doymet, aes(x=doy, y=med_var2)) +
  geom_ribbon(data=doymet, aes(x=doy, ymin=min_var2, ymax=max_var2), alpha=0.3) +
  geom_line(data=thisyear, aes(x=doy, y=med_var2), color="red", size=1) +
  ggtitle(paste(var2name,
                max(weather$year, na.rm=TRUE),
                sep=" ")) +
  xlab("Day of the year") + ylab(var2name)
grid.arrange(plot1, plot2, nrow=2)

# simplify the district names
weather$district <- simplifynames(weather$district)
diagnostic_weatherdistricts <- unique(weather$district)
# remove any districts which do not belong
weather <- weather[weather$district %in% unique(district_shapes$district),]
```
```{r silentsaveweather, include=FALSE, echo=FALSE}
# put aside this set for use in the regression
dailyextr <- weather
rm(weather)
gc()

if (ostype == "windows") { 
  
  ggsave(paste(graphicoutputdir,
               "var1.png",
               sep=""), plot1)
  ggsave(paste(graphicoutputdir,
               "var2.png",
               sep=""), plot2)
  
}
```


\newpage
## Vector infection data

```{r mosquitodataread, echo=FALSE} 

wnv <- read.csv(mosqfile, stringsAsFactors=FALSE)
wnv$col_date <- as.Date(wnv$col_date, "%m/%d/%Y")
wnv$year <- as.numeric(format(wnv$col_date, "%Y"))

```


```{r mosquitodataprocess, echo=FALSE}
# convert district to factor
wnv$district <- simplifynames(wnv$district)
diagnostic_mosquitodistricts <- unique(wnv$district)
# remove any which do not belong
wnv <- wnv[wnv$district %in% unique(district_shapes$district),]
wnv$district <- factor(wnv$district)

# convert date to a date object
wnv$col_date <- as.Date(wnv$col_date, '%m/%d/%Y')

# figure out how many rows we start with
nrow1 <- nrow(wnv)

# create some variables we can use to filter
wnv$col_year <- as.numeric(format(wnv$col_date, "%Y"))
wnv$doy      <- as.numeric(format(wnv$col_date, "%j"))
wnv$weeknum  <- as.numeric(format(wnv$col_date, "%U"))
wnv$species <- NULL
wnv$district <- factor(wnv$district)
wnv$district <- droplevels(wnv$district)

# figure out which years we're modeling
minmosqyear <- min(wnv$year, na.rm=TRUE)

# get rid of those which don't have a result
wnv <- wnv[which(!is.na(wnv$wnv_result)),]
wnv <- wnv[which(!is.na(wnv$doy)),]

# delete anything before a certain day
wnv <- wnv[which(wnv$doy >= 100),]
# delete anything after a certain day
wnv <- wnv[which(wnv$doy <= 212),]

# after cleaning, how many do we have?
nrow2 <- nrow(wnv)
nrow3 <- nrow(wnv[wnv$year == maxmosqyear,])

tempdf <- wnv[wnv$year == maxmosqyear,]
tempdf <- tempdf[!is.na(tempdf$wnv_result),]
wnvdenominator <- nrow(tempdf)
wnvnumerator <- nrow(tempdf[tempdf$wnv_result == 1,])

numpos <- wnvnumerator
perpos <- 100*round(wnvnumerator/wnvdenominator, 3)
```

There are `r nrow2` samples in the vector testing database. For `r maxmosqyear`, there are `r nrow3` tested samples, with `r numpos` (`r perpos`%) positive. The estimated risk of human infection due to the early-season vector infection growth rate is shown below. Higher means that the pathogen is spreading more rapidly among vectors, and more human cases should be expected. The regions used for stratification are mapped below; districts are thought to share risk more closely with others in the same strata, although all districts share some level of risk with all other districts.  

```{r mosquitodataprocess2, fig.width=7, fig.height=3, echo=FALSE, include=FALSE}
# import district identifiers
strata <- read.csv(stratafile)
strata$district <- simplifynames(strata$district)
strata <- strata[c("district", "strata")]
wnv <- merge(x=wnv, y=strata,
             by.x="district",
             by.y="district",
             all.x=TRUE)

# figure out how many distinct districts we have left
districtlist           <- data.frame(district=unique(wnv$district))
distinctdistricts      <- length(unique(wnv$district))
districtlist$districtnum <- seq(from=1, to=distinctdistricts, by=1)
wnv <- merge(x=wnv, y=districtlist,
             by="district",
             all=TRUE)

# create a variable that at least has a little chance of being orthogonal to 1.
wnv$dminus <- wnv$doy - mean(wnv$doy, na.rm=TRUE)

# make sure all the observations have a stratum and year
wnv <- wnv[!is.na(wnv$strata),]
wnv <- wnv[!is.na(wnv$year),]

# run a random effect model on orthogonalized data
infectglm <- glmer(wnv_result ~ 1+dminus+
                    (0+1|year) +
                    (0+dminus|year) +
                    (0+1|strata:year) + 
                    (0+dminus|strata:year),
                  family=binomial(),
                  data=wnv)

wnv$est <- predict(infectglm, newdata=wnv, type="response")

if (ostype == "windows") { 
  
  write.csv(x=wnv, file=paste(mosqmatoutputdir,
                              "mosqmatrix.csv",
                              sep=""))
  
}

# predict random effects for all years
# dminus cannot be set to simply 0 - we have to make sure this isn't read in as a factor
randeffs <- expand.grid(strata=unique(wnv$strata),
                        year=minmosqyear:maxmosqyear,
                        dminus=0.00001)
randeffs <- randeffs[which(!is.na(randeffs$strata)),]
# if you don't allow new levels, the most recent year might not have an estimate
randeffs$mosqinfect <- predict(infectglm, newdata=randeffs, allow.new.levels = TRUE)
randeffs$stratayear <- paste(randeffs$strata, randeffs$year, sep=":")
randeffs$adjmosqinfect <- randeffs$mosqinfect - mean(randeffs$mosqinfect,na.rm=TRUE)
randeffs$stratum <- factor(randeffs$strata)
```
```{r fig.width=7, fig.height=3, echo=FALSE, include=TRUE}
thisplot <- ggplot(randeffs) + geom_line(aes(x=year, y=adjmosqinfect, group=stratum, color=stratum)) +
  geom_abline(slope=0, intercept=0, linetype=2) +
  scale_x_continuous(breaks=minmosqyear:maxmosqyear) +
  theme(axis.text.x=element_text(angle=45, hjust=1),
        panel.grid.minor=element_blank(),
        panel.grid.major.y=element_blank())+
  xlab("") + ylab("Relative risk due to\nvector infection growth rate")
plot(thisplot)
```
```{r silentsavemosq, include=FALSE, echo=FALSE}
if (ostype == "windows") {
  
  ggsave(paste(graphicoutputdir,
               "vector infection rates.png",
               sep=""), thisplot)
  
}
```

```{r humandata, include=FALSE, echo=TRUE}

# import data
human <- read.csv(humandatafile)
begrow <- nrow(human)
human$chardate <- as.character(levels(human$date))[as.numeric(human$date)]
human$date <- as.Date(human$date, "%m/%d/%Y")
human$creationyear <- as.numeric(format(human$date, "%Y"))
human$creationmonth <- as.numeric(format(human$date, "%m"))
# simplify district names
human$district <- simplifynames(human$district)
diagnostic_humandistricts <- unique(human$district)
# remove any which do not belong
human <- human[human$district %in% unique(district_shapes$district),]
human$district <- factor(human$district)
human$doy <- as.numeric(format(human$date, "%j"))

# retain only those in the right date range
hWNVminyear <- minmosqyear
hWNVmaxyear <- maxmosqyear-1
human <- human[which((human$creationyear >= hWNVminyear) & (human$creationyear <= hWNVmaxyear)),]

# figure out in which months we have at least one case
observedcreationmonths <- count(human, vars=creationmonth)

# create the full list of weeks
minobservedhumandate <- min(human$date)

# set up the data frame so that it ends at the maxdesiredhumandate 
filledweeks <- seq(from=maxdesiredhumandate, to=minobservedhumandate, by=-7)

fullcasemat <- expand.grid(sort(unique(human$district)), filledweeks)
names(fullcasemat) <- c("district", "weekstartdate")
head(fullcasemat)
fullcasemat$anycases   <- rep(0, nrow(fullcasemat))
fullcasemat$totalcases <- rep(0, nrow(fullcasemat))
fullcasemat$observed   <- 1*((fullcasemat$weekstartdate >= minobservedhumandate)&
                             (fullcasemat$weekstartdate <= maxobservedhumandate))
# only model cases during months in which some cases have been observed
fullcasemat$month    <- as.numeric(format(fullcasemat$weekstartdate, "%m"))
fullcasemat$observed <- fullcasemat$observed * (fullcasemat$month %in% observedcreationmonths$vars)
fullcasemat$month    <- NULL

for (i in 1:nrow(fullcasemat)) {
  
  thisweekstartdate <- fullcasemat$weekstartdate[i]
  thisdistrict        <- fullcasemat$district[i]
  
  tempcases <- human[which(human$district == thisdistrict),]
  tempcases <- tempcases[which(tempcases$date >= thisweekstartdate),]
  tempcases <- tempcases[which(tempcases$date <= (thisweekstartdate + 6)),]
  
  fullcasemat$anycases[i] <- 1*(nrow(tempcases) > 0)
  if (nrow(tempcases) > 0) {
    
    fullcasemat$totalcases[i] <- nrow(tempcases)
    
  }
  
}
totcase <- sum(fullcasemat$totalcases, na.rm=TRUE)
anypos  <- sum(fullcasemat$anycases, na.rm=TRUE)

# figure out what percentage of cases we'll likely have seen before the start of this week
weekinquestionSundoy <- as.numeric(format(weekinquestionSun, "%j"))
fullcasemat$doy      <- as.numeric(format(fullcasemat$weekstartdate, "%j"))

tempdf <- fullcasemat[fullcasemat$doy < (weekinquestionSundoy+7),]
observedbefore <- sum(tempdf$totalcases, na.rm=TRUE)
observedtotal  <- sum(fullcasemat$totalcases, na.rm=TRUE)
weekinquestionreformat <- format(weekinquestionSun, "%m-%d")
observedfraction <- 100*round(observedbefore / observedtotal, 2)
```
```{r stratamap, include=FALSE, echo=FALSE}
crs(district_shapes) <- "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80     +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
projected_districts <- spTransform(district_shapes, crs("+proj=longlat +datum=WGS84 +no_defs"))
projected_districts@data$id = rownames(projected_districts@data)
projected_districts.df <- tidy(projected_districts)
projected_districts.df <- left_join(projected_districts.df, projected_districts@data, by="id")

stratamapcsv <- read.csv(stratafile)
stratamapcsv$district <- simplifynames(stratamapcsv$district)
stratamapcsv <- stratamapcsv[c("district", "strata")]

projected_districts.df <- left_join(projected_districts.df, stratamapcsv,
                                   by="district")

projected_districts.df$stratum <- factor(projected_districts.df$strata.x)
```
```{r stratmap2, include=TRUE, echo=FALSE, fig.width=7, fig.height=3}
thisplot <- ggplot(projected_districts.df) +
      aes(long,lat,fill=stratum,group=group,id=id,guides=FALSE) +
      geom_polygon() + xlab("") + ylab("") +
      geom_path(color="black") +
      theme(legend.position="bottom") +
      coord_map() + ggtitle("State stratification map") +
        theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
            axis.ticks = element_blank(), axis.text.x = element_blank(),
            axis.text.y = element_blank(), axis.title.x=element_blank(),
            axis.title.y = element_blank(),
            legend.position="right",
            legend.key.width=unit(1, "cm"),
            legend.key.height=unit(0.5,"cm"))
plot(thisplot)
```
```{r silentsave88791122823, include=FALSE, echo=FALSE}
if (ostype == "windows") {
  
  ggsave(paste(graphicoutputdir,
               "strata.png",
               sep=""), thisplot)
  
}
```

The following graph shows the estimated growth of positive samples for every year (grey), with `r compyear1` (blue) and `r compyear2` (blue, dashed) selected for comparison, and estimates and observations for `r maxmosqyear` (red). The lines are modeled sample positive rates; the actual statewide positive sample rate for `r maxmosqyear` is shown here by grouping observations nearby in time.

```{r mosqbymonth, include=TRUE, echo=FALSE, fig.width=6, fig.height=3}
mosqmopreds <- expand.grid(strata=unique(wnv$strata),
                           year=minmosqyear:maxmosqyear,
                           doy=seq(from=min(wnv$doy, na.rm=TRUE),
                                   to  =max(wnv$doy, na.rm=TRUE), by=1))
mosqmopreds$dminus <- mosqmopreds$doy - mean(wnv$doy, na.rm=TRUE)
mosqmopreds$preds <- predict(infectglm, newdata=mosqmopreds, type="response", allow.new.levels=TRUE)

mosqmopreds <- group_by(mosqmopreds, dminus, year)
mosqmopreds <- dplyr::summarize(mosqmopreds,
                         preds=mean(preds, na.rm=TRUE),
                         doy=mean(doy, na.rm=TRUE))
thisyear1   <- mosqmopreds[mosqmopreds$year == maxmosqyear,]
comparison1 <- mosqmopreds[mosqmopreds$year == compyear1,]
comparison2 <- mosqmopreds[mosqmopreds$year == compyear2,]

thisyeardot <- wnv[wnv$year == maxmosqyear,]

if (sum(!is.na(thisyeardot$doy)) > 20) {

  thisyeardot$rounddoy <- cut2(thisyeardot$doy, g=6)
  thisyeardot <- group_by(thisyeardot, rounddoy)
  thisyeardot <- dplyr::summarize(thisyeardot,
                        meanpos = mean(wnv_result, na.rm=TRUE),
                        meandoy = mean(doy, na.rm=TRUE))
  thisplot <- ggplot(data=mosqmopreds) + geom_line(data=mosqmopreds, aes(x=doy, y=preds, group=year),
                                                   color="grey", alpha=0.5) +
    geom_line(data=comparison1, aes(x=doy, y=preds), color="blue") +
    geom_line(data=comparison2, aes(x=doy, y=preds), color="blue", linetype=2) +
    geom_line(data=thisyear1, aes(x=doy, y=preds), color="red") +
    geom_point(data=thisyeardot, aes(x=meandoy, y=meanpos), color="red") +
    xlab("day of the year") + ylab("Vector pool positive rate") +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.background = element_blank(),
          axis.line = element_line(colour = "black"))
  
} else {
  
  thisplot <- ggplot(data=mosqmopreds) + geom_line(data=mosqmopreds, aes(x=doy, y=preds, group=year),
                                                   color="grey", alpha=0.5) +
    geom_line(data=comparison1, aes(x=doy, y=preds), color="blue") +
    geom_line(data=comparison2, aes(x=doy, y=preds), color="blue", linetype=2) +
    geom_line(data=thisyear1, aes(x=doy, y=preds), color="red") +
    xlab("day of the year") + ylab("Vector pool positive rate") +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.background = element_blank(),
          axis.line = element_line(colour = "black"))
  
}


plot(thisplot)
```
```{r include=FALSE, echo=FALSE}
if (ostype == "windows") { 
  
  ggsave(paste(graphicoutputdir,
               "mosqinfectgrowthrates.png",
               sep=""), thisplot)
  
}
```


## Human data

The predictive model of human cases was calibrated using `r totcase` historical cases, not including any cases from `r maxmosqyear`. No cases from `r maxmosqyear` are used to make predictions; the estimates for this year are based solely on weather and vector data. Typically, `r observedfraction`% of a year's cases occur before the end of this week in any given year.

# Model results

## Statewide trends

The graphs below show observed statewide risk (black) and estimated risk (red) up to `r maxdesiredhumandatestr` `r maxdesiredhumandate`. Observed risk should be completely zero during the last year - these data are not used in the model, and will only be updated once final human case data are received at the end of the year.

```{r humandata2, echo=TRUE, warnings=FALSE, include=FALSE}
# select which variables we're going to use!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
dailyextr <- data.frame(dailyextr)
dailyextr$var1 <- dailyextr[,which(colnames(dailyextr) == var1name)]
dailyextr$var2 <- dailyextr[,which(colnames(dailyextr) == var2name)]
dailyextr <- dailyextr[c("district","date","var1","var2")]
dailyextr$district <- simplifynames(dailyextr$district)
# fill in missing and future climatological data
totaldailyextr <- expand.grid(district=unique(dailyextr$district),
                              date=seq(from=as.Date(paste((minmosqyear-1), "-01-01", sep=""),
                                                    "%Y-%m-%d"),
                                       to=maxdesiredhumandate,
                                       by=1))
dailyextr <- merge(x=totaldailyextr, y=dailyextr,
                   by.x=c("district","date"),
                   by.y=c("district","date"),
                   all.x=TRUE)
dailyextr$doy <- as.numeric(format(dailyextr$date, "%j"))

dailyextr <- group_by(dailyextr, district, doy)
districtdoymean <- dplyr::summarize(dailyextr,
                           meanvar1=mean(var1, na.rm=TRUE),
                           meanvar2=mean(var2, na.rm=TRUE))
dailyextr <- ungroup(dailyextr)                           

dailyextr <- left_join(dailyextr, districtdoymean,
                   by=c("district","doy"))

dailyextr$var1[is.na(dailyextr$var1)] <- dailyextr$meanvar1[is.na(dailyextr$var1)]
dailyextr$var2[is.na(dailyextr$var2)] <- dailyextr$meanvar2[is.na(dailyextr$var2)]

# garbage collection
rm(districtdoymean)
dailyextr$meanvar1 <- NULL
dailyextr$meanvar2 <- NULL
gc()

# we need the districts to be in lower case to merge with the gridMET data
fullcasemat$district <- simplifynames(fullcasemat$district)

datalagger <- expand.grid(unique(fullcasemat$district),
                          unique(fullcasemat$weekstartdate),
                          seq(from=0, to=laglen-1, by=1))
names(datalagger) <- c("district","date","lag")
datalagger$laggeddate <- datalagger$date-datalagger$lag

datalagger <- left_join(datalagger, dailyextr,
                        by=c("district"="district",
                             "laggeddate"="date"))

# garbage collection
rm(dailyextr)
gc()

# pivot
mean1data <- dcast(datalagger, district + date ~ lag, value.var="var1")
names(mean1data) <- paste("var1_",names(mean1data),sep="")
head(mean1data)

mean2data <- dcast(datalagger, district + date ~ lag, value.var="var2")
names(mean2data) <- paste("var2_",names(mean2data),sep="")
head(mean2data)

# garbage collection
rm(datalagger)
gc()

# and put all this lagged info back into the total case matrix
fullcasemat <- merge(x=fullcasemat, y=mean1data,
                     by.x=c("district", "weekstartdate"),
                     by.y=c("var1_district","var1_date"),
                     all.x=TRUE)
fullcasemat <- merge(x=fullcasemat, y=mean2data,
                     by.x=c("district", "weekstartdate"),
                     by.y=c("var2_district","var2_date"),
                     all.x=TRUE)

# turn these into matrices
fullcasemat$var1 <- as.matrix(fullcasemat[,grep(x=colnames(fullcasemat),
                                                pattern="var1_",
                                                fixed=TRUE)])
fullcasemat$var2 <- as.matrix(fullcasemat[,grep(x=colnames(fullcasemat),
                                                pattern="var2_",
                                                fixed=TRUE)])
fullcasemat[,grep(x=colnames(fullcasemat), pattern="var1_", fixed=TRUE)] <- NULL
fullcasemat[,grep(x=colnames(fullcasemat), pattern="var2_", fixed=TRUE)] <- NULL

# import strata
fullcasemat <- merge(x=fullcasemat, y=strata,
                     by.x="district", by.y="district",
                     all.x=TRUE)

# create lag matrix
fullcasemat$lag <- fullcasemat$var1
for (curcol in 1:dim(fullcasemat$lag)[2]) {
  
  fullcasemat$lag[,curcol] <- (curcol-1)

}

# if necessary, create sindoy cosdoy for the wheel of the year
if (splineevolution == "seasonallyvarying") {
  
  fullcasemat$doymat <- fullcasemat$lag
  fullcasemat$doymat[,] <- fullcasemat$doy

}

# garbage collection
rm(mean1data)
rm(mean2data)
gc()

# include the mosquito summary statistic
stratayearmosq <- randeffs
stratayearmosq <- stratayearmosq[c("stratayear","mosqinfect")]
names(stratayearmosq) <- c("stratayear","MIRsummarystat")

fullcasemat$year <- as.numeric(format(fullcasemat$weekstartdate, "%Y"))
fullcasemat$stratayear <- paste(fullcasemat$strata, fullcasemat$year, sep=":")
fullcasemat$year <- NULL

fullcasemat <- merge(x=fullcasemat, y=stratayearmosq,
                     by.x="stratayear", by.y="stratayear",
                     all.x=TRUE)

# calculate missing MIRsummarystat
stratayearmosq$strata <- substr(stratayearmosq$stratayear, 1, 3)
tempdf <- aggregate(stratayearmosq$MIRsummarystat,
                    by=list(stratayearmosq$strata),
                    FUN=mean,
                    na.rm=TRUE)
names(tempdf) <- c("strata","MIRsummarystat2")

fullcasemat <- merge(x=fullcasemat, y=tempdf,
                     by.x="strata", by.y="strata",
                     all.x=TRUE)
fullcasemat$MIRsummarystat[is.na(fullcasemat$MIRsummarystat)] <- fullcasemat$MIRsummarystat2[is.na(fullcasemat$MIRsummarystat)]

fullcasemat$strata <- NULL
fullcasemat$stratayear <- NULL

fullcasemat <- ungroup(fullcasemat)
```

```{r humanreg, echo=FALSE, include=FALSE}
# get rid of districts that never have a positive case in the time period
fullcasemat$doy <- as.numeric(format(fullcasemat$weekstartdate, "%j"))

# make sure district is a factor before modeling
fullcasemat$district <- factor(fullcasemat$district)

# create formula
if (splinetype == "thinplate") {
  
  myformula <- "s(lag, by=var1, bs='tp') + s(lag, by=var2, bs='tp')"

}
if (splinetype == "fixeddfcr") {
  
  myformula <- "s(lag, by=var1, bs='cr', fx=TRUE, k=6) + s(lag, by=var2, bs='cr', fx=TRUE, k=6)"
}

if (anomalization == "anomalized") {
  
  myformula <- paste(myformula, " + s(doy, bs='cc')", sep="")
  
}

if (splineevolution == "seasonallyvarying") {
  
  myformula <- gsub(x=myformula,
                    pattern="s(lag, ",
                    fixed=TRUE,
                    replacement = "te(lag, doymat, ")
  
}

myformula <- paste("anycases ~ 0 + MIRsummarystat + district", myformula, sep=" + ")
myform <- as.formula(myformula)




# main human risk model
cl <- makeCluster(detectCores(logical=FALSE)-1)
firstreg  <- bam(formula=myform,
                 family=binomial(), data=fullcasemat,
                 subset=observed==1,
                 cluster=cl)
stopCluster(cl)

# save the model
save(firstreg, file=paste(modeloutputdir,
                          splinetype, "-",
                          splineevolution, "-",
                          anomalization,
                          ".RData", sep=""))

# show predictions
preds <- predict(firstreg, newdata=fullcasemat, newlevels=TRUE, type="response")
fullcasemat$est <- preds
preds <- data.frame(est=preds)

```

```{r humanregplot, echo=FALSE}
tempdf <- data.frame(weekstartdate=fullcasemat$weekstartdate,
                     obs=fullcasemat$anycases,
                     est=preds$est,
                     observed=fullcasemat$observed)
tempdf$week <- as.numeric(format(tempdf$weekstartdate, "%U"))

# figure out in which weeks we actually have cases, for the purpose of graphin
tempdf <- group_by(tempdf, obs)
tempsum <- dplyr::summarise(tempdf,
                            minweek=min(week, na.rm=TRUE),
                            maxweek=max(week, na.rm=TRUE))
minweek <- tempsum$minweek[tempsum$obs==1]
maxweek <- tempsum$maxweek[tempsum$obs==1]

tempdf <- tempdf[tempdf$week >= minweek,]
tempdf <- tempdf[tempdf$week <= maxweek,]

tempdf <- group_by(tempdf, weekstartdate)
tempdf <- dplyr::summarize(tempdf,
                    obs=mean(obs, na.rm=TRUE),
                    est=mean(est, na.rm=TRUE),
                    week=mean(week, na.rm=TRUE))

tempdf$newwe <- (tempdf$week - minweek) / (maxweek - minweek + 1)
tempdf$year <- as.numeric(format(tempdf$weekstartdate, "%Y"))
tempdf$newdate <- tempdf$year + tempdf$newwe
```

```{r fig.width=7, fig.height=3.5, echo=FALSE, warnings=FALSE}
thisplot <- ggplot(tempdf) + geom_line(aes(x=newdate,
                               y=obs)) +
  geom_line(aes(x=newdate, y=est), color="red") +
  ggtitle("Statewide model predictions") +
  xlab("") + ylab("") +
  scale_x_continuous(breaks=seq(from=minmosqyear,to=(maxmosqyear+1),by=1),
                     labels=c(seq(from=minmosqyear, to=maxmosqyear, by=1), ""),
                     limits=c((minmosqyear+0.125),(maxmosqyear+1))) +
  ylab("Proportion of districts positive") +
  theme(panel.grid.minor.x=element_blank()) +
  theme(axis.text.x = element_text(hjust=-0.225))
plot(thisplot)
```
```{r silentsave8879823, include=FALSE, echo=FALSE}
if (ostype == "windows") {
 
  ggsave(paste(graphicoutputdir,
               "predictions.png",
               sep=""), thisplot)

}
```
```{r curyearplot, include=TRUE, echo=FALSE, fig.width=7, fig.height=3.5}

tempdf <- fullcasemat
tempdf <- group_by(tempdf, weekstartdate)
tempdf <- dplyr::summarize(tempdf,
                    obs=mean(anycases, na.rm=TRUE),
                    est=mean(est, na.rm=TRUE))
tempdf$year <- as.numeric(format(tempdf$weekstartdate, "%Y"))
tempdf$month <- as.numeric(format(tempdf$weekstartdate, "%m"))

tempdf <- tempdf[tempdf$month >= min(observedcreationmonths$vars),]
tempdf <- tempdf[tempdf$month <= max(observedcreationmonths$vars),]

thisyear <- tempdf[tempdf$year == maxmosqyear,]
comparison1 <- tempdf[tempdf$year == compyear1,]
comparison2 <- tempdf[tempdf$year == compyear2,]

comparison1$weekstartdate <- comparison1$weekstartdate + (maxmosqyear - compyear1)*365
comparison2$weekstartdate <- comparison2$weekstartdate + (maxmosqyear - compyear2)*365

tempdf <- bind_rows(thisyear,
                    comparison1,
                    comparison2)

tempdf$est[tempdf$year == compyear1] <- tempdf$obs[tempdf$year == compyear1]
tempdf$est[tempdf$year == compyear2] <- tempdf$obs[tempdf$year == compyear2]
tempdf$year <- factor(tempdf$year)

tempdf2 <- thisyear[thisyear$weekstartdate >= weekinquestionSun,]
tempdf2 <- tempdf2[1,]
```
\newpage
Predictions for `r maxmosqyear` are compared to observations in `r compyear1` and `r compyear2`. We expect `r round(66*tempdf2$est,1)` districts to have at least one human case between `r weekinquestionSunstr` `r weekinquestionSun` and `r weekinquestionSatstr` `r weekinquestionSat`.

```{r plotblah, include=TRUE, echo=FALSE, fig.width=7, fig.height=3.5}
thisplot <- ggplot(tempdf) + geom_line(data=tempdf, aes(x=weekstartdate,
                           y=est,
                           color=year,
                           linetype=year)) +
  geom_point(data=tempdf2, aes(x=weekstartdate, y=est), color="red", size=4)+
  xlab("") + ylab("") +
  scale_x_date(date_labels="%b", date_breaks="1 month",
               limits=c(as.Date(paste(maxmosqyear, "-05-01", sep=""), "%Y-%m-%d"),
                        as.Date(paste(maxmosqyear, "-11-15", sep=""), "%Y-%m-%d")),
               labels=c("May","Jun","Jul","Aug","Sep","Oct","Nov","")) +
  ylab("Proportion of districts positive") +
  theme(panel.grid.minor.x=element_blank()) +
  scale_linetype_manual(values=c(3,2,1)) +
  scale_color_manual(values=c("black","black","red"))
thisplot1 <- thisplot + ggtitle(paste("Estimates for ",
                maxmosqyear, " compared to observations in ", compyear1, " and ", compyear2,
                "\nwith week beginning ", weekinquestionSun, " highlighted", sep="")) +
  theme(axis.text.x = element_text(hjust=-1.25))
plot(thisplot1)
```
```{r silentsave12899234, include=FALSE, echo=FALSE}
thisplot2 <- thisplot + theme(legend.position="bottom") +
  theme(axis.text.x = element_text(hjust=-0.50))

if (ostype == "windows") { 

  ggsave(paste(graphicoutputdir,
               "estimates.png",
               sep=""), thisplot2,
         width=4,
         height=4)

}
```

```{r echo=FALSE}
if (ostype == "windows") {
  
  write.csv(x=fullcasemat[c("district","weekstartdate",
                            "anycases","totalcases", "est")],
            file=paste(fullcasematoutputdir, "case matrix.csv", sep=""))
  
}
fullcasemat$year <- as.numeric(format(fullcasemat$weekstartdate, "%Y"))
thisyear <- fullcasemat[fullcasemat$year == maxmosqyear,]
previousyears <- fullcasemat[fullcasemat$year < maxmosqyear,]
sumtotal <- sum(previousyears$totalcases, na.rm=TRUE)
sumany   <- sum(previousyears$anycases, na.rm=TRUE)

positivesthisyear <- round(sum(thisyear$est, na.rm=TRUE), 1)

byyear <- dplyr::summarize(group_by(previousyears, year),
                           totobs = sum(totalcases, na.rm=TRUE),
                           anyobs = sum(anycases, na.rm=TRUE),
                           weight = 1)
byyear <- bind_rows(byyear, data.frame(totobs=0,
                                       anyobs=0,
                                       weight=100))

relationship <- gam(totobs ~ s(anyobs), weights=weight, data=byyear)

predframe <- data.frame(anyobs = seq(from=0,
                                     to=max(byyear$anyobs, na.rm=TRUE),
                                     length.out=50))
predframe$preds <- predict(relationship, newdata = predframe)

predframe2 <- data.frame(anyobs = sum(thisyear$est, na.rm=TRUE))
predframe2$preds  <- predict(relationship, newdata = predframe2)

ggplot() + geom_line(data=predframe, aes(x=anyobs, y=preds), color="red", linetype=2) +
  geom_abline(slope=1, intercept=0, color="grey", linetype=2) +
  geom_point(data=predframe2, aes(x=anyobs, y=preds), color="red", size=5) +
  geom_point(data=byyear, aes(x=anyobs, y=totobs)) +
  #geom_abline(slope=1, intercept=0, color="red", linetype=2) +
  xlab("positive county-weeks in a year") + ylab("total cases that year") 
```

We expect that there will be `r positivesthisyear` positive district-weeks this year. Since ArboMAP models positive district-weeks rather than total cases, we can only make a rough estimate based on the relationship of cases to district-weeks. If historical patterns hold (dashed red line), we expect there to be `r round(predframe2$preds,1)` cases this year (red dot). The grey line indicates the case count if there were only one case per positive district-week. Especially in the height of the season, some districts that have one case that week will have more than one case.

## Results for `r weekinquestionSun` to `r format(weekinquestionSat, "%m-%d")`

We visualize the raw estimated risk for `r weekinquestion` below. If a district is darkest blue, then we estimate that there should be no human cases reported for this district, during this week. If a district is brightest red, we are certain that there will be at least one human case reported for this district, during this week.

```{r shapefile, include=FALSE, echo=FALSE, warnings=FALSE}
district_shapes <- readShapePoly(districtshapefile)
district_shapes$NAME <- simplifynames(district_shapes$NAME)
crs(district_shapes) <- "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80     +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
projected_districts <- spTransform(district_shapes, crs("+proj=longlat +datum=WGS84 +no_defs"))
projected_districts@data$id = rownames(projected_districts@data)
projected_districts.df <- tidy(projected_districts)
projected_districts.df <- left_join(projected_districts.df, projected_districts@data, by="id")
projected_districts.df$district <- simplifynames(projected_districts.df$NAME)

# get this week's predictions
thisweek <- fullcasemat[fullcasemat$weekstartdate >= weekinquestion,]
thisweek <- thisweek[thisweek$weekstartdate == min(thisweek$weekstartdate, na.rm=TRUE),]
thisweek <- thisweek[c("district", "est")]

projected_districts.df <- left_join(projected_districts.df, thisweek,
                                   by="district")
projected_districts.df$est[is.na(projected_districts.df$est)] <- min(projected_districts.df$est, na.rm=TRUE)
```
```{r shapefile2, include=TRUE, echo=FALSE, fig.width=7, fig.height=3.5}
thisplot <- ggplot(projected_districts.df) +
      aes(long,lat,fill=est,group=group,id=id,guides=FALSE) +
      geom_polygon() + xlab("") + ylab("") +
      geom_path(color="black") +
      theme(legend.position="bottom") +
      scale_fill_distiller(palette = "Spectral", limits=c(0,1),
                                                 breaks = c(0,1),
                                                 labels = c("Will definitely not\nreport any cases",
                                                            "Will definitely\nreport some cases"),
                                                     name = "") +
      coord_map() + ggtitle(paste("Estimate for week beginning ",
                            weekinquestionSun,
                            sep="")) +
        theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
            axis.ticks = element_blank(), axis.text.x = element_blank(),
            axis.text.y = element_blank(), axis.title.x=element_blank(),
            axis.title.y = element_blank(),
            legend.position="bottom",
            legend.key.width=unit(1, "cm"),
            legend.key.height=unit(0.25,"cm"))
plot(thisplot)
```
```{r silentsave89712, include=FALSE, echo=FALSE}
if (ostype == "windows") {
  
  ggsave(paste(graphicoutputdir,
               "map absolute.png",
               sep=""), thisplot)
  
}
```

This map indicates whether probabilities reported in the previous map are higher (red) than average, lower (blue) than average, or right about normal (yellow) compared to the same week in previous years.

```{r riskcalcs, include=TRUE, echo=FALSE, fig.width=7, fig.height=3.5}
thisweek <- fullcasemat[fullcasemat$weekstartdate >= weekinquestion,]
thisweek <- thisweek[thisweek$weekstartdate == min(thisweek$weekstartdate, na.rm=TRUE),]
thisweek <- thisweek[c("district", "est", "doy")]

approxdoy <- thisweek$doy[1]

fullcasemat$year <- as.numeric(format(fullcasemat$weekstartdate, "%Y"))

doypreds <- data.frame()
for (curyear in unique(fullcasemat$year)) {
  
  for (curdistrict in unique(fullcasemat$district)) {
    
    thisdf <- fullcasemat[fullcasemat$year == curyear,]
    thisdf <- thisdf[thisdf$district == curdistrict,]
    
    if(sum(!is.na(thisdf$est)) > 1) {
    
      tempdf <- data.frame(district = curdistrict,
                           year = curyear,
                           est = approx(x=thisdf$doy,
                                        y=thisdf$est,
                                        xout=approxdoy)$y)
      
      doypreds <- bind_rows(doypreds, tempdf)
      
    }
    
  }
  
}

doypreds2 <- data.frame()
for (curdistrict in unique(doypreds$district)) {

  tempdf <- doypreds[doypreds$district == curdistrict,]
  tempdf$percentile <- rank(tempdf$est, ties.method="random") / length(tempdf$est)
  
  doypreds2 <- bind_rows(doypreds2, tempdf)
  
}
doypreds <- doypreds2
rm(doypreds2)

riskalpha <- 0.25
doypreds$riskcategory <- " About average    "
doypreds$riskcategory[doypreds$percentile <= riskalpha/2] <- " Lower than usual    "
doypreds$riskcategory[doypreds$percentile >= 1-(riskalpha/2)] <- " Higher than usual    "
doypredscurrent <- doypreds[doypreds$year == as.numeric(format(weekinquestion, "%Y")),]
projected_districts.df <- left_join(projected_districts.df, doypredscurrent,
                                   by="district")
projected_districts.df$riskcategory[is.na(projected_districts.df$riskcategory)] <- " Not able to model    "
thisplotrisk <- ggplot(projected_districts.df) +
      aes(long,lat,fill=riskcategory,group=group,guides=FALSE) +
      geom_polygon() + 
      geom_path(color="black") +
      coord_map() + 
      ggtitle("") +
      theme(text=element_text(size=15)) +
      theme(plot.title=element_text(size=15),
            legend.key=element_rect(fill="white")) +
      theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
            axis.ticks = element_blank(), axis.text.x = element_blank(),
            axis.text.y = element_blank(), axis.title.x=element_blank(),
            axis.title.y = element_blank(),
            legend.position="bottom",
            legend.key.width=unit(1, "cm"),
            legend.key.height=unit(0.5,"cm")) +
      theme(legend.direction="vertical") +
      scale_fill_manual(name=paste("Risk for ", weekinquestionSun, " to ",
                                   format(weekinquestionSat, "%m-%d"), sep=""),
                        values=c(" Lower than usual    "="lightblue",
                                 " About average    "="yellow",
                                 " Higher than usual    "="red",
                                 " Not able to model    "="grey"))


plot(thisplotrisk)
```
```{r silentsave1245, include=FALSE, echo=FALSE}
if (ostype == "windows") { 
  
  ggsave(paste(graphicoutputdir,
               "map relative.png",
               sep=""), thisplotrisk,
         width=4,
         height=4)
}
sitegraphic <- grid.arrange(thisplotrisk +
                            theme(legend.position="right",
                                  legend.direction="vertical") +
                            scale_fill_manual(name="Risk this week",
                            values=c(" Lower than usual    "="lightblue",
                                     " About average    "="yellow",
                                     " Higher than usual    "="red",
                                     " Not able to model    "="grey")) +
                            #ylab("hidden axis") +
                            #theme(axis.title.y = element_text(colour = "white")) +
                            theme(legend.key.width=unit(0.25, "cm"),
                            legend.key.height=unit(0.50,"cm"),
                            text=element_text(size=10)) + 
                            theme(plot.margin = unit(c(0,0,0,0.4), "cm")),
  
                            # t r b l
                            
                            thisplot2 +
                            theme(legend.position="right") + ylab("") +
                            theme(axis.text.x=element_text(family="mono"))+
                            theme(panel.grid.minor=element_blank(),
                                  axis.text.y=element_blank(),
                                  axis.ticks=element_blank())+
                            theme(axis.text.x = element_text(hjust=-0.35)) +
                            theme(plot.margin = unit(c(0.1,0.2,0.1,-0.1), "cm")), nrow=2) 

if (ostype == "windows") {
  
  ggsave(paste(graphicoutputdir,
               "site graphic.png",
               sep=""), sitegraphic,
         width=4,
         height=4)
}
```

\newpage
## Dependence on environmental data.

Below, we visualize the distributed lags on environmental data. If a line is above (below) zero at some lag, this means risk today depends positively (negatively) on the environmental data at that date in the past.

```{r distributedlags, include=FALSE, echo=FALSE}
mygam <- plot(firstreg, select=1)
if (splineevolution == "notevolving") {

  for (i in 1:length(mygam)) {
  
    thisplot <- mygam[[i]]
    
    if (grepl(x=thisplot$ylab,
              pattern="var1",
              fixed=TRUE)) {
  
        lag1df <- data.frame(fit=thisplot$fit,
                             x  =thisplot$`x`)
  
    }
  
    if (grepl(x=thisplot$ylab,
              pattern="var2",
              fixed=TRUE)) {
  
        lag2df <- data.frame(fit=thisplot$fit,
                             x  =thisplot$`x`)
        
      }
  
    }
  
}
if (splineevolution == "seasonallyvarying") {
  
  for (i in 1:length(mygam)) {
    
    thisplot <- mygam[[i]]
    if (length(thisplot$main) > 0) {
    
      if (grepl(x=thisplot$main,
                pattern=":var1",
                fixed=TRUE)) {
        
          lag1df <- expand.grid(x=thisplot$x,
                                y=thisplot$y)
          lag1df$fit <- thisplot$fit
          
      }
      if (grepl(x=thisplot$main,
                pattern=":var2",
                fixed=TRUE)) {
        
          lag2df <- expand.grid(x=thisplot$x,
                                y=thisplot$y)
          lag2df$fit <- thisplot$fit
          
      }
      
    }
    
  }
  
}
```
```{r dlplots, include=TRUE, echo=FALSE, fig.width=7, fig.height=3.5}
if (splineevolution == "notevolving") {

  thisplot1 <- ggplot(lag1df) + geom_line(aes(x=x, y=fit)) +
    ggtitle(paste("distributed lags on ", var1name, sep="")) + xlab("lag")
  thisplot2 <- ggplot(lag2df) + geom_line(aes(x=x, y=fit)) +
    ggtitle(paste("distributed lags on ", var2name, sep="")) + xlab("lag")

  plot(thisplot1)
  plot(thisplot2)
  
}
if (splineevolution == "seasonallyvarying") {
  
  select_1_y <- quantile(lag1df$y, probs=c(0.45, 0.50, 0.65), type=1)
  lag1df <- lag1df[lag1df$y %in% select_1_y,]
  lag1df$dayofyear <- factor(round_any(lag1df$y,1))
  
  select_2_y <- quantile(lag2df$y, probs=c(0.45, 0.50, 0.65), type=1)
  lag2df <- lag2df[lag2df$y %in% select_2_y,]
  lag2df$dayofyear <- factor(round_any(lag2df$y,1))
  
  thisplot1 <- ggplot(lag1df) + geom_line(aes(x=x, y=fit, group=dayofyear, color=dayofyear)) +
    ggtitle(paste("distributed lags on ", var1name, sep="")) + xlab("lag")
  thisplot2 <- ggplot(lag2df) + geom_line(aes(x=x, y=fit, group=dayofyear, color=dayofyear)) +
    ggtitle(paste("distributed lags on ", var2name, sep="")) + xlab("lag")
  
  
  plot(thisplot1)
  plot(thisplot2)
  
}

```



\newpage 

The following two graphs show the influences of the two environmental covariates on estimated risk. The current year (red) is compared to all others (black). If the line is higher, this indicates the variable in the past has a positive influence on risk estimated for that date.

```{r envinfluences, include=TRUE, echo=FALSE, fig.width=7, fig.height=3.5}
termdf <- data.frame(predict(firstreg, newdata=fullcasemat, type="terms"))
termdf$date <- fullcasemat$weekstartdate
termdf$doy  <- fullcasemat$doy
termdf$year <- fullcasemat$year

termdf$var1inf <- psum(termdf[,grep(x=colnames(termdf),
                                    pattern="var1",
                                    fixed=TRUE)], na.rm=TRUE)
termdf$var2inf <- psum(termdf[,grep(x=colnames(termdf),
                                    pattern="var2",
                                    fixed=TRUE)], na.rm=TRUE)

termdf <- group_by(termdf,
                   year,
                   doy)
termsum <- dplyr::summarise(termdf,
                            var1inf=mean(var1inf, na.rm=TRUE),
                            var2inf=mean(var2inf, na.rm=TRUE))

termsum <- termsum[termsum$doy >= 150,]
termsum <- termsum[termsum$doy <= 250,]

maxyear <- termsum[termsum$year == max(termsum$year, na.rm=TRUE),]
termdf$year <- factor(termdf$year)

thisplot1 <- ggplot() + geom_line(data=termsum, aes(x=doy, y=var1inf, group=year), alpha=0.5) +
  geom_line(data=maxyear, aes(x=doy, y=var1inf), color="red", size=2) +
  ggtitle(paste("Relative influence of ", var1name, sep="")) +
  xlab("day of year") + ylab("relative influence")
thisplot2 <- ggplot() + geom_line(data=termsum, aes(x=doy, y=var2inf, group=year), alpha=0.5) +
  geom_line(data=maxyear, aes(x=doy, y=var2inf), color="red", size=2) +
  ggtitle(paste("Relative influence of ", var2name, sep="")) +
  xlab("day of year") + ylab("relative influence")

plot(thisplot1)
plot(thisplot2)

```

\newpage 
### Diagnostics

## Model summary

```{r modelfit, include=FALSE, echo=FALSE}
myroc <- roc(response = fullcasemat$anycases,
             predictor = fullcasemat$est,
             na.rm=TRUE,
             auc=TRUE)
# calculate AUC on full set
myauctotal <- myroc$auc
# calculate hoslem on full set
tempdf <- fullcasemat[c("anycases", "est")]
tempdf <- tempdf[!is.na(tempdf$anycases),]
tempdf <- tempdf[!is.na(tempdf$est),]
myhoslemtotal <- hoslem.test(x=tempdf$anycases,
                             y=tempdf$est)$p.value

# do the same on restricted set
fullcasemat$month <- as.numeric(format(fullcasemat$weekstartdate, "%m"))
fullcasemat <- group_by(fullcasemat, month)
monthsum <- dplyr::summarise(fullcasemat,
                             numpos = sum(anycases, na.rm=TRUE))
monthsum <- monthsum[monthsum$numpos > 0,]
tempdf   <- fullcasemat[fullcasemat$month %in% monthsum$month,]

tempdf2 <- tempdf[c("anycases", "est")]
tempdf2 <- tempdf2[!is.na(tempdf2$anycases),]
tempdf2 <- tempdf2[!is.na(tempdf2$est),]

myroc <- roc(response = tempdf$anycases,
             predictor = tempdf$est,
             na.rm=TRUE,
             auc=TRUE)
myaucrestricted <- myroc$auc
myhoslemrestricted <- hoslem.test(x=tempdf2$anycases,
                                  y=tempdf2$est)$p.value
```

The model achieved an AUC (or c-stat) of `r round_any(myauctotal, 0.01)` when tested on all available human case data. When restricted to the months with at least one human case, the model achieved an AUC of `r round_any(myaucrestricted, 0.01)`. The p-value in a Hosmer-Lemeshow goodness of fit test was `r round_any(myhoslemtotal, 0.0001)` on the full set and `r round_any(myhoslemrestricted, 0.0001)` on the restricted set. The model achieved an AIC of `r round_any(AIC(firstreg)[1], 0.01)` when calculated on the full set.

## District names

It is possible that district names in the human, mosquito, or weather data might disagree with the names found in the district shapefile. We have chosen the shapefile to unify all of the various data sources, so the human, mosquito, and weather data files should be updated to match these. Typically, check the TIGER shapefiles or census for standardized names.

```{r diagnostics, include=FALSE, echo=FALSE}
humannotinshapefile <- diagnostic_humandistricts[!(diagnostic_humandistricts %in% diagnostic_shapefiledistricts)]
if (length(humannotinshapefile) == 0) { humannotinshapefile <- "none" }

mosquitonotinshapefile <- diagnostic_mosquitodistricts[!(diagnostic_mosquitodistricts %in% diagnostic_shapefiledistricts)]
if (length(mosquitonotinshapefile) == 0) { mosquitonotinshapefile <- "none" }

weathernotinshapefile <- diagnostic_weatherdistricts[!(diagnostic_weatherdistricts %in% diagnostic_shapefiledistricts)]
if (length(weathernotinshapefile) == 0) { weathernotinshapefile <- "none" }
```

There are `r length(diagnostic_shapefiledistricts)` districts in the shapefile. This is the maximum number of districts ArboMAP will recognize in the human, mosquito, or weather data.

There are `r length(diagnostic_humandistricts)` districts in the human WNV data. If some districts never reported cases, this number may be less than the number of districts in the shapefile. If there are more, there are likely misspellings in the human data file. Human districts not found in the district shapefile: `r humannotinshapefile`.

There are `r length(diagnostic_mosquitodistricts)` districts in the mosquito WNV data. If some districts never reported mosquito data, this number may be less than the number of districts in the shapefile. Mosquito districts not found in the district shapefile: `r mosquitonotinshapefile`.

There are `r length(diagnostic_weatherdistricts)` districts in the mosquito WNV data. If these data were downloaded with the GEE app, they should match the shapefile districts exactly. Weather districts not found in the district shapefile: `r weathernotinshapefile`.


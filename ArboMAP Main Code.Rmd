---
title: "ArboMAP: Arbovirus Modeling and Prediction   \nto Forecast Mosquito-Borne Disease Outbreaks"
author: "Summary of Model Outputs (v2.1)   \nJustin K. Davis and Michael C. Wimberly  \n(justinkdavis@ou.edu, mcwimberly@ou.edu)  \nGeography and Environmental Sustainability, University of Oklahoma"
date: "Updated `r format(Sys.time(), '%B %d, %Y')`"
output: pdf_document
---

```{r setup, include=FALSE}
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)
# define some helpful functions
'%!in%' <- function(x,y)!('%in%'(x,y))
round_any = function(x, accuracy, f=round){f(x/accuracy) * accuracy}
options(warn=-1)
```

```{r createfunctions, include=FALSE}
simplifynames <- function(priornames=NULL) {

  # convert to lower case
  priornames <- tolower(priornames)
  
  # remove spaces
  priornames <- gsub(pattern=" ", replacement="", x=priornames, fixed=TRUE)
  
  # remove district and parish
  priornames <- gsub(pattern="county", replacement="", x=priornames, fixed=TRUE)
  priornames <- gsub(pattern="parish", replacement="", x=priornames, fixed=TRUE)

  # return names
  return(priornames)
  
}
```

```{r libraries, include=FALSE}
packages <- c("reshape2", "ggplot2", "gridExtra",
              "lme4","pracma","dplyr","maptools",
              "raster","spdep","mgcv","sp","rgdal",
              "GISTools","data.table","splines","maps",
              "broom","mapproj", "Hmisc", "parallel",
              "rccmisc", "pROC", "ResourceSelection",
              "knitr")
for (package in packages) {
    if (!require(package, character.only=T, quietly=T)) {
        install.packages(package, repos = "http://cran.us.r-project.org")
        library(package, character.only=T)
    }
}
```

```{r setoptions, include=FALSE, echo=FALSE}

# operating system
# it's possible we could detect this on our own, but it's simpler for the user to simply specify
ostype <- "windows"
if (!(ostype %in% c("windows", "mac"))) { ostype <- "windows" }

# model names
modelnames <- c("tp-sv-anom", "cub-fx-nonanom", "cub-sv-nonanom")

# model formulas
modelformulas <- c("cub-fx-nonanom"   = "anycases ~ 0 + district + MIRsummarystat + s(lag, by=var1, bs='cr') + s(lag, by=var2, bs='cr')",
                   "cub-sv-nonanom"   = "anycases ~ 0 + district + MIRsummarystat + te(lag, doymat, by=var1, bs='cr') + te(lag, doymat, by=var2, bs='cr')",
                   "tp-fx-nonanom"    = "anycases ~ 0 + district + MIRsummarystat + s(lag, by=var1, bs='tp') + s(lag, by=var2, bs='tp')",
                   "tp-sv-anom"       = "anycases ~ 0 + district + MIRsummarystat + te(lag, doymat, by=anom_var1, bs='tp') + te(lag, doymat, by=anom_var2, bs='tp') + s(doy, bs='tp')")

# adjust smoothness
modelgamma <- 1.0

# where do we want the outputs? 
graphicoutputdir <- ".\\graphical outputs\\"
fullcasematoutputdir <- ".\\case matrix with estimates\\"
mosqmatoutputdir <- ".\\mosquito matrix with estimates\\"
modeloutputdir <- ".\\model output\\"

# where are the human data located?
# example of a file with directories an drive:
humandatafile <- ".\\human case data\\simulated human case data.csv"
#humandatafile <- "C:\\home\\work\\davis\\ArboMAP for Mike on 19-08-13\\human\\19-01-29 - reconciled human WNV.csv"

# what is the date of the last human case we're willing to believe?
# probably, cut this off at the end of last year
# DO NOT use any human cases from the year you're modeling
maxobservedhumandate <- as.Date("2017-12-31", "%Y-%m-%d")

# cull some proportion of the outlying human cases
humancasealpha <- 0.02

# which week are we producing the graphs for?
weekinquestion <- as.Date("2018-09-15", "%Y-%m-%d")

# where are the weather csv files stored?
weatherpathstr <- ".\\weather data\\"
#weatherpathstr <- "C:\\home\\work\\davis\\ArboMAP for Mike on 19-08-13\\weather\\"

# what is the name of the summary file to be created?
weathersummaryfile <- "weather data summary file.csv"

# which variables do you want to use?
var1name <- "tmeanc"
var2name <- "vpd"

# where are the mosquito test files located?
mosqfile <- ".\\mosquito data\\simulated mosquito tests.csv"
#mosqfile <- "C:\\home\\work\\davis\\ArboMAP for Mike on 19-08-13\\mosquito\\19-01-29 - state testing.csv"

# which district stratification scheme are we using?
stratafile <- ".\\strata\\17-04-20 - classified strata - classic.csv"

# where is the districtshapefile
districtshapefile <- ".\\shapefile\\cb_2014_us_county_5m - in EPSG 5070 - only SD.shp"

# to which two other years do we want to compare the current year's predictions?
compyear1 <- 2012
compyear2 <- 2017

# probably don't want to modify what follows, but you have some options if you're comfortable
# makes sure we round to the previous Sunday, so that this week is included
weekinquestionSun <- weekinquestion - (as.numeric(strftime(weekinquestion, '%u')) %% 7)
weekinquestionSat <- weekinquestionSun + 6
weekinquestionSunstr <- strftime(weekinquestionSun, '%A')
weekinquestionSatstr <- strftime(weekinquestionSat, '%A')

# figure out which year this is and begin all weeks on Sunday
maxmosqyear <- as.numeric(format(weekinquestion, "%Y"))
maxdesiredhumandate <- as.Date(paste(maxmosqyear,
                                     "-12-31",sep=""))
maxdesiredhumandate <- maxdesiredhumandate - (as.numeric(strftime(maxdesiredhumandate, '%u')) %% 7)
maxdesiredhumandatestr <- strftime(maxdesiredhumandate, '%A')

# make sure the max desired human date is no earlier than the week in question
# otherwise, there will be no predictions for the week in question
maxdesiredhumandate <- max(weekinquestionSun+7, maxdesiredhumandate)

# set up lag and regression information
laglen   <- 181
dlagdeg  <- 8

# mac file setup
if (ostype == "mac") {

  # where do we want the outputs?
  graphicoutputdir <- "./graphical outputs/"
  fullcasematoutputdir <- "./case matrix with estimates/"
  mosqmatoutputdir <- "./mosquito matrix with estimates/"
  modeloutputdir <- "./model output/"
  
  # where are the human data located?
  # example of a file with directories an drive:
  humandatafile <- "./human case data/simulated human case data.csv"
  
  # where are the weather csv files stored?
  weatherpathstr <- "./weather data/"
  
  # what is the name of the summary file to be created?
  weathersummaryfile <- "weather data summary file.csv"
  
  # where are the mosquito test files located?
  mosqfile <- "./mosquito data/simulated mosquito tests.csv"
  
  # which district stratification scheme are we using?
  stratafile <- "./strata/17-04-20 - classified strata - classic.csv"
  
  # where is the districtshapefile
  districtshapefile <- "./shapefile/cb_2014_us_county_5m - in EPSG 5070 - only SD.shp"
  
}
```

# Data used for predictions
## Weather data

```{r weatherdataload, include=FALSE, echo=TRUE}
# load the shapefile immediately so that we can get rid of any districts which are not found here
district_shapes <- readShapePoly(districtshapefile)
# simplify name
district_shapes$district <- simplifynames(district_shapes$NAME)
diagnostic_shapefiledistricts <- unique(district_shapes$district)

weathernames <- c("district", "doy", "year", var1name, var2name)

# load and concat files
weatherlist <- list.files(path=weatherpathstr, pattern="(.csv)", recursive=FALSE)
weather <- data.frame()
for (i in 1:length(weatherlist)) {
  
  if (weatherlist[[i]] != weathersummaryfile) {
  
    tempdf <- read.csv(paste(weatherpathstr, weatherlist[[i]], sep="")) 
    # get rid of the variables we aren't using
    tempdf <- tempdf[,weathernames]
    weather <- bind_rows(weather, tempdf)  
    
  }
  
}
weather$date <- as.Date(paste(weather$year,
                              weather$doy,
                              sep="-"),
                        "%Y-%j")

# get rid of duplicated rows
weather$districtdate <- paste(weather$district, weather$date)
weather <- subset(weather, !duplicated(weather$districtdate))

# be certain district is a factor before modeling
weather$district <- factor(weather$district)

# create the anomalized weather
for (curcol in c(var1name, var2name)) {
      
    weather$tempvar <- weather[,curcol]
    tempmod <- bam(tempvar ~ district + s(doy, bs="cc", by=district), data=weather, discrete=TRUE)
    weather[,paste("anom_", curcol, sep="")] <- resid(tempmod)
    
}
weather$tempvar <- NULL
 
# plot normals and this year
weather$var1 <- weather[,which(colnames(weather) == var1name)]
weather$var2 <- weather[,which(colnames(weather) == var2name)]
weather$anom_var1 <- weather[,which(colnames(weather) == paste("anom_", var1name, sep=""))]
weather$anom_var2 <- weather[,which(colnames(weather) == paste("anom_", var2name, sep=""))]

weather <- group_by(weather,
                    doy)
doymet <- dplyr::summarise(weather,
                           med_var1 = quantile(var1, probs=0.50, na.rm=TRUE),
                           med_var2 = quantile(var2, probs=0.50, na.rm=TRUE),
                           max_var1 = max(var1, na.rm=TRUE),
                           max_var2 = max(var2, na.rm=TRUE),
                           min_var1 = min(var1, na.rm=TRUE),
                           min_var2 = min(var2, na.rm=TRUE),
                           anom_med_var1 = quantile(anom_var1, probs=0.50, na.rm=TRUE),
                           anom_med_var2 = quantile(anom_var2, probs=0.50, na.rm=TRUE),
                           anom_max_var1 = max(anom_var1, na.rm=TRUE),
                           anom_max_var2 = max(anom_var2, na.rm=TRUE),
                           anom_min_var1 = min(anom_var1, na.rm=TRUE),
                           anom_min_var2 = min(anom_var2, na.rm=TRUE))
weather <- ungroup(weather)

thisyear <- max(weather$year, na.rm=TRUE)
thisyear <- subset(weather, year == thisyear)
thisyear <- group_by(thisyear, doy)
thisyear <- dplyr::summarize(thisyear,
                             med_var1 = quantile(var1, probs=0.50, na.rm=TRUE),
                             med_var2 = quantile(var2, probs=0.50, na.rm=TRUE),
                             max_var1 = max(var1, na.rm=TRUE),
                             max_var2 = max(var2, na.rm=TRUE),
                             min_var1 = min(var1, na.rm=TRUE),
                             min_var2 = min(var2, na.rm=TRUE),
                             anom_med_var1 = quantile(anom_var1, probs=0.50, na.rm=TRUE),
                             anom_med_var2 = quantile(anom_var2, probs=0.50, na.rm=TRUE),
                             anom_max_var1 = max(anom_var1, na.rm=TRUE),
                             anom_max_var2 = max(anom_var2, na.rm=TRUE),
                             anom_min_var1 = min(anom_var1, na.rm=TRUE),
                             anom_min_var2 = min(anom_var2, na.rm=TRUE))

weather$var1 <- NULL
weather$var2 <- NULL
weather$anom_var1 <- NULL
weather$anom_var2 <- NULL

tempdf <- left_join(doymet, thisyear, by="doy")
```

Weather data from the gridMET data set range from `r min(weather$date, na.rm=TRUE)` to `r max(weather$date, na.rm=TRUE)`. Below are graphs of statewide daily averages of `r var1name` and `r var2name`. Observations for the current year are in red. Black is the medium from all other years, and the grey band indicates the max/min ever observed. Below this are the anomalized weather indices, from which the weekly averages have been subtracted to show deviations above/below the mean.

```{r weatherplots, fig.width=7, fig.height=5, echo=FALSE}
plot1 <- ggplot() + geom_line(data=doymet, aes(x=doy, y=med_var1)) +
  geom_ribbon(data=doymet, aes(x=doy, ymin=min_var1, ymax=max_var1), alpha=0.3) +
  geom_line(data=thisyear, aes(x=doy, y=med_var1), color="red", size=1) +
  xlab("Day of the year") + ylab(var1name) +
  ggtitle(paste(var1name, 
                max(weather$year, na.rm=TRUE),
                sep=" "))
plot2 <- ggplot() + geom_line(data=doymet, aes(x=doy, y=med_var2)) +
  geom_ribbon(data=doymet, aes(x=doy, ymin=min_var2, ymax=max_var2), alpha=0.3) +
  geom_line(data=thisyear, aes(x=doy, y=med_var2), color="red", size=1) +
  ggtitle(paste(var2name,
                max(weather$year, na.rm=TRUE),
                sep=" ")) +
  xlab("Day of the year") + ylab(var2name)
grid.arrange(plot1, plot2, nrow=2)

plot3 <- ggplot() + geom_line(data=doymet, aes(x=doy, y=anom_med_var1)) +
  geom_ribbon(data=doymet, aes(x=doy, ymin=anom_min_var1, ymax=anom_max_var1), alpha=0.3) +
  geom_line(data=thisyear, aes(x=doy, y=anom_med_var1), color="red", size=1) +
  xlab("Day of the year") + ylab(var1name) +
  ggtitle(paste("anomalized",
                var1name, 
                max(weather$year, na.rm=TRUE),
                sep=" "))
plot4 <- ggplot() + geom_line(data=doymet, aes(x=doy, y=anom_med_var2)) +
  geom_ribbon(data=doymet, aes(x=doy, ymin=anom_min_var2, ymax=anom_max_var2), alpha=0.3) +
  geom_line(data=thisyear, aes(x=doy, y=anom_med_var2), color="red", size=1) +
  ggtitle(paste("anomalized",
                var2name,
                max(weather$year, na.rm=TRUE),
                sep=" ")) +
  xlab("Day of the year") + ylab(var2name)
grid.arrange(plot3, plot4, nrow=2)

# simplify the district names
weather$district <- simplifynames(weather$district)
diagnostic_weatherdistricts <- unique(weather$district)
# remove any districts which do not belong
weather <- weather[weather$district %in% unique(district_shapes$district),]
```
```{r silentsaveweather, include=FALSE, echo=FALSE}
# put aside this set for use in the regression
dailyextr <- weather
rm(weather)
gc()

if (ostype == "windows") { 
  
  ggsave(paste(graphicoutputdir,
               "var1.png",
               sep=""), plot1)
  ggsave(paste(graphicoutputdir,
               "var2.png",
               sep=""), plot2)
  
}
```

## Vector infection data

```{r mosquitodataread, echo=FALSE} 

wnv <- read.csv(mosqfile, stringsAsFactors=FALSE)
wnv$col_date <- as.Date(wnv$col_date, "%m/%d/%Y")
wnv$year <- as.numeric(format(wnv$col_date, "%Y"))

```


```{r mosquitodataprocess, echo=FALSE}
# convert district to factor
wnv$district <- simplifynames(wnv$district)
diagnostic_mosquitodistricts <- unique(wnv$district)
# remove any which do not belong
wnv <- wnv[wnv$district %in% unique(district_shapes$district),]
wnv$district <- factor(wnv$district)

# convert date to a date object
wnv$col_date <- as.Date(wnv$col_date, '%m/%d/%Y')

# figure out how many rows we start with
nrow1 <- nrow(wnv)

# create some variables we can use to filter
wnv$col_year <- as.numeric(format(wnv$col_date, "%Y"))
wnv$doy      <- as.numeric(format(wnv$col_date, "%j"))
wnv$weeknum  <- as.numeric(format(wnv$col_date, "%U"))
wnv$species <- NULL
wnv$district <- factor(wnv$district)
wnv$district <- droplevels(wnv$district)

# figure out which years we're modeling
minmosqyear <- min(wnv$year, na.rm=TRUE)

# get rid of those which don't have a result
wnv <- wnv[which(!is.na(wnv$wnv_result)),]
wnv <- wnv[which(!is.na(wnv$doy)),]

# delete anything before a certain day
wnv <- wnv[which(wnv$doy >= 100),]
# delete anything after a certain day
wnv <- wnv[which(wnv$doy <= 212),]

# after cleaning, how many do we have?
nrow2 <- nrow(wnv)
nrow3 <- nrow(wnv[wnv$year == maxmosqyear,])

tempdf <- wnv[wnv$year == maxmosqyear,]
tempdf <- tempdf[!is.na(tempdf$wnv_result),]
wnvdenominator <- nrow(tempdf)
wnvnumerator <- nrow(tempdf[tempdf$wnv_result == 1,])

numpos <- wnvnumerator
perpos <- 100*round(wnvnumerator/wnvdenominator, 3)
```

There are `r nrow2` samples in the vector testing database. For `r maxmosqyear`, there are `r nrow3` tested samples, with `r numpos` (`r perpos`%) positive. The estimated risk of human infection due to the early-season vector infection growth rate is shown below. Higher means that the pathogen is spreading more rapidly among vectors, and more human cases should be expected. The regions used for stratification are mapped below; districts are thought to share risk more closely with others in the same strata, although all districts share some level of risk with all other districts.  

```{r mosquitodataprocess2, fig.width=7, fig.height=3, echo=FALSE, include=FALSE}
# import district identifiers
strata <- read.csv(stratafile)
strata$district <- simplifynames(strata$district)
strata <- strata[c("district", "strata")]
wnv <- merge(x=wnv, y=strata,
             by.x="district",
             by.y="district",
             all.x=TRUE)

# figure out how many distinct districts we have left
districtlist           <- data.frame(district=unique(wnv$district))
distinctdistricts      <- length(unique(wnv$district))
districtlist$districtnum <- seq(from=1, to=distinctdistricts, by=1)
wnv <- merge(x=wnv, y=districtlist,
             by="district",
             all=TRUE)

# create a variable that at least has a little chance of being orthogonal to 1.
wnv$dminus <- wnv$doy - mean(wnv$doy, na.rm=TRUE)

# make sure all the observations have a stratum and year
wnv <- wnv[!is.na(wnv$strata),]
wnv <- wnv[!is.na(wnv$year),]

# run a random effect model on orthogonalized data
infectglm <- glmer(wnv_result ~ 1+dminus+
                    (0+1|year) +
                    (0+dminus|year) +
                    (0+1|strata:year) + 
                    (0+dminus|strata:year),
                  family=binomial(),
                  data=wnv)

wnv$est <- predict(infectglm, newdata=wnv, type="response")

if (ostype == "windows") { 
  
  write.csv(x=wnv, file=paste(mosqmatoutputdir,
                              "mosqmatrix.csv",
                              sep=""))
  
}

# predict random effects for all years
# dminus cannot be set to simply 0 - we have to make sure this isn't read in as a factor
randeffs <- expand.grid(strata=unique(wnv$strata),
                        year=minmosqyear:maxmosqyear,
                        dminus=0.00001)
randeffs <- randeffs[which(!is.na(randeffs$strata)),]
# if you don't allow new levels, the most recent year might not have an estimate
randeffs$mosqinfect <- predict(infectglm, newdata=randeffs, allow.new.levels = TRUE)
randeffs$stratayear <- paste(randeffs$strata, randeffs$year, sep=":")
randeffs$adjmosqinfect <- randeffs$mosqinfect - mean(randeffs$mosqinfect,na.rm=TRUE)
randeffs$stratum <- factor(randeffs$strata)
```
```{r fig.width=7, fig.height=3, echo=FALSE, include=TRUE}
thisplot <- ggplot(randeffs) + geom_line(aes(x=year, y=adjmosqinfect, group=stratum, color=stratum)) +
  geom_abline(slope=0, intercept=0, linetype=2) +
  scale_x_continuous(breaks=minmosqyear:maxmosqyear) +
  theme(axis.text.x=element_text(angle=45, hjust=1),
        panel.grid.minor=element_blank(),
        panel.grid.major.y=element_blank())+
  xlab("") + ylab("Relative risk due to\nvector infection growth rate")
plot(thisplot)
```
```{r silentsavemosq, include=FALSE, echo=FALSE}
if (ostype == "windows") {
  
  ggsave(paste(graphicoutputdir,
               "vector infection rates.png",
               sep=""), thisplot)
  
}
```

```{r humandata, include=FALSE, echo=TRUE}

# import data
human <- read.csv(humandatafile)
begrow <- nrow(human)
human$chardate <- as.character(levels(human$date))[as.numeric(human$date)]
human$date <- as.Date(human$date, "%m/%d/%Y")
human$creationyear <- as.numeric(format(human$date, "%Y"))
human$creationmonth <- as.numeric(format(human$date, "%m"))
# simplify district names
human$district <- simplifynames(human$district)
diagnostic_humandistricts <- unique(human$district)
# remove any which do not belong
human <- human[human$district %in% unique(district_shapes$district),]
human$district <- factor(human$district)
human$doy <- as.numeric(format(human$date, "%j"))

# retain only those in the right date range
hWNVminyear <- minmosqyear
hWNVmaxyear <- maxmosqyear-1
human <- human[which((human$creationyear >= hWNVminyear) & (human$creationyear <= hWNVmaxyear)),]

# figure out which chunk of data we should be analyzing
human$weeknum <- as.numeric(format(human$date, "%U"))
minmaxweekquants <- quantile(human$weeknum, probs=c(humancasealpha/2, 1-humancasealpha/2), na.rm=TRUE)
humanminobsweek <- minmaxweekquants[1]
humanmaxobsweek <- minmaxweekquants[2]

# create the full list of weeks
minobservedhumandate <- min(human$date)

# set up the data frame so that it ends at the maxdesiredhumandate 
filledweeks <- seq(from=maxdesiredhumandate, to=minobservedhumandate, by=-7)

fullcasemat <- expand.grid(sort(unique(human$district)), filledweeks)
names(fullcasemat) <- c("district", "weekstartdate")
head(fullcasemat)
fullcasemat$anycases   <- rep(0, nrow(fullcasemat))
fullcasemat$totalcases <- rep(0, nrow(fullcasemat))
fullcasemat$observed   <- 1*((fullcasemat$weekstartdate >= minobservedhumandate)&
                             (fullcasemat$weekstartdate <= maxobservedhumandate))

# mark those district-weeks which are in the modeled set
fullcasemat$weeknum <- as.numeric(format(fullcasemat$weekstartdate, "%U"))
fullcasemat$modeled <- fullcasemat$observed * (fullcasemat$weeknum >= humanminobsweek) * (fullcasemat$weeknum <= humanmaxobsweek)

# count cases
for (i in 1:nrow(fullcasemat)) {
  
  thisweekstartdate <- fullcasemat$weekstartdate[i]
  thisdistrict      <- fullcasemat$district[i]
  
  tempcases <- human[which(human$district == thisdistrict),]
  tempcases <- tempcases[which(tempcases$date >= thisweekstartdate),]
  tempcases <- tempcases[which(tempcases$date <= (thisweekstartdate + 6)),]
  
  fullcasemat$anycases[i] <- 1*(nrow(tempcases) > 0)
  if (nrow(tempcases) > 0) {
    
    fullcasemat$totalcases[i] <- nrow(tempcases)
    
  }
  
}

totcase <- sum(fullcasemat$totalcases, na.rm=TRUE)
anypos  <- sum(fullcasemat$anycases, na.rm=TRUE)

# figure out what percentage of cases we'll likely have seen before the start of this week
weekinquestionSundoy <- as.numeric(format(weekinquestionSun, "%j"))
fullcasemat$doy      <- as.numeric(format(fullcasemat$weekstartdate, "%j"))

tempdf <- fullcasemat[fullcasemat$doy < (weekinquestionSundoy+7),]
observedbefore <- sum(tempdf$totalcases, na.rm=TRUE)
observedtotal  <- sum(fullcasemat$totalcases, na.rm=TRUE)
weekinquestionreformat <- format(weekinquestionSun, "%m-%d")
observedfraction <- 100*round(observedbefore / observedtotal, 2)
```
```{r stratamap, include=FALSE, echo=FALSE}
crs(district_shapes) <- "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80     +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
projected_districts <- spTransform(district_shapes, crs("+proj=longlat +datum=WGS84 +no_defs"))
projected_districts@data$id = rownames(projected_districts@data)
projected_districts.df <- tidy(projected_districts)
projected_districts.df <- left_join(projected_districts.df, projected_districts@data, by="id")

stratamapcsv <- read.csv(stratafile)
stratamapcsv$district <- simplifynames(stratamapcsv$district)
stratamapcsv <- stratamapcsv[c("district", "strata")]

projected_districts.df <- left_join(projected_districts.df, stratamapcsv,
                                   by="district")

projected_districts.df$stratum <- factor(projected_districts.df$strata.x)
```
```{r stratmap2, include=TRUE, echo=FALSE, fig.width=7, fig.height=3}
thisplot <- ggplot(projected_districts.df) +
      aes(long,lat,fill=stratum,group=group,id=id,guides=FALSE) +
      geom_polygon() + xlab("") + ylab("") +
      geom_path(color="black") +
      theme(legend.position="bottom") +
      coord_map() + ggtitle("State stratification map") +
        theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
            axis.ticks = element_blank(), axis.text.x = element_blank(),
            axis.text.y = element_blank(), axis.title.x=element_blank(),
            axis.title.y = element_blank(),
            legend.position="right",
            legend.key.width=unit(1, "cm"),
            legend.key.height=unit(0.5,"cm"))
plot(thisplot)
```
```{r silentsave88791122823, include=FALSE, echo=FALSE}
if (ostype == "windows") {
  
  ggsave(paste(graphicoutputdir,
               "strata.png",
               sep=""), thisplot)
  
}
```

The following graph shows the estimated growth of positive samples for every year (grey), with `r compyear1` (blue) and `r compyear2` (blue, dashed) selected for comparison, and estimates and observations for `r maxmosqyear` (red). The lines are modeled sample positive rates; the actual statewide positive sample rate for `r maxmosqyear` is shown here by grouping observations nearby in time.

```{r mosqbymonth, include=TRUE, echo=FALSE, fig.width=6, fig.height=3}
mosqmopreds <- expand.grid(strata=unique(wnv$strata),
                           year=minmosqyear:maxmosqyear,
                           doy=seq(from=min(wnv$doy, na.rm=TRUE),
                                   to  =max(wnv$doy, na.rm=TRUE), by=1))
mosqmopreds$dminus <- mosqmopreds$doy - mean(wnv$doy, na.rm=TRUE)
mosqmopreds$preds <- predict(infectglm, newdata=mosqmopreds, type="response", allow.new.levels=TRUE)

mosqmopreds <- group_by(mosqmopreds, dminus, year)
mosqmopreds <- dplyr::summarize(mosqmopreds,
                         preds=mean(preds, na.rm=TRUE),
                         doy=mean(doy, na.rm=TRUE))
thisyear1   <- mosqmopreds[mosqmopreds$year == maxmosqyear,]
comparison1 <- mosqmopreds[mosqmopreds$year == compyear1,]
comparison2 <- mosqmopreds[mosqmopreds$year == compyear2,]

thisyeardot <- wnv[wnv$year == maxmosqyear,]

if (sum(!is.na(thisyeardot$doy)) > 20) {

  thisyeardot$rounddoy <- cut2(thisyeardot$doy, g=6)
  thisyeardot <- group_by(thisyeardot, rounddoy)
  thisyeardot <- dplyr::summarize(thisyeardot,
                        meanpos = mean(wnv_result, na.rm=TRUE),
                        meandoy = mean(doy, na.rm=TRUE))
  thisplot <- ggplot(data=mosqmopreds) + geom_line(data=mosqmopreds, aes(x=doy, y=preds, group=year),
                                                   color="grey", alpha=0.5) +
    geom_line(data=comparison1, aes(x=doy, y=preds), color="blue") +
    geom_line(data=comparison2, aes(x=doy, y=preds), color="blue", linetype=2) +
    geom_line(data=thisyear1, aes(x=doy, y=preds), color="red") +
    geom_point(data=thisyeardot, aes(x=meandoy, y=meanpos), color="red") +
    xlab("day of the year") + ylab("Vector pool positive rate") +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.background = element_blank(),
          axis.line = element_line(colour = "black"))
  
} else {
  
  thisplot <- ggplot(data=mosqmopreds) + geom_line(data=mosqmopreds, aes(x=doy, y=preds, group=year),
                                                   color="grey", alpha=0.5) +
    geom_line(data=comparison1, aes(x=doy, y=preds), color="blue") +
    geom_line(data=comparison2, aes(x=doy, y=preds), color="blue", linetype=2) +
    geom_line(data=thisyear1, aes(x=doy, y=preds), color="red") +
    xlab("day of the year") + ylab("Vector pool positive rate") +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.background = element_blank(),
          axis.line = element_line(colour = "black"))
  
}


plot(thisplot)
```
```{r include=FALSE, echo=FALSE}
if (ostype == "windows") { 
  
  ggsave(paste(graphicoutputdir,
               "mosqinfectgrowthrates.png",
               sep=""), thisplot)
  
}
```

## Human data

In the graph below, positive districts by week are shown over all years. Only weeks within the two dashed lines (excluding `r 100*humancasealpha`% total of the earliest and latest cases) are used in modeling for numerical stability.

```{r humandatasummary, echo=FALSE, include=TRUE, fig.width=7, fig.height=3.5}
fullcasemat$weeknum <- as.numeric(format(fullcasemat$weekstartdate, "%U"))
fullcasemat <- group_by(fullcasemat, weeknum)
sumanyhumancases <- dplyr::summarise(fullcasemat, totany = sum(anycases, na.rm=TRUE))
fullcasemat <- ungroup(fullcasemat)

ggplot(sumanyhumancases) + geom_line(aes(x=weeknum, y=totany)) +
  ggtitle("positive districts by week, any year") +
  xlab("week number") + ylab("total districts positive") +
  geom_vline(xintercept=humanminobsweek, linetype=2) +
  geom_vline(xintercept=humanmaxobsweek, linetype=2) +
  scale_x_continuous(breaks=seq(from=min(sumanyhumancases$weeknum),
                                to=max(sumanyhumancases$weeknum),
                                by=2))
```

The predictive model of human cases was calibrated using `r totcase` historical cases, not including any cases from `r maxmosqyear`. No cases from `r maxmosqyear` are used to make predictions; the estimates for this year are based solely on weather and vector data. Typically, `r observedfraction`% of a year's cases occur before the end of this week in any given year.

# Model results

## Statewide trends

The graphs below show observed statewide risk (black) and estimated risk (red) up to `r maxdesiredhumandatestr` `r maxdesiredhumandate`. Observed risk should be completely zero during the last year - these data are not used in the model, and will only be updated once final human case data are received at the end of the year.

```{r humandata2, echo=TRUE, warnings=FALSE, include=FALSE}
# select which variables we're going to use
dailyextr <- data.frame(dailyextr)
dailyextr$var1 <- dailyextr[,which(colnames(dailyextr) == var1name)]
dailyextr$var2 <- dailyextr[,which(colnames(dailyextr) == var2name)]

dailyextr$anom_var1 <- dailyextr[,which(colnames(dailyextr) == paste("anom_", var1name, sep=""))]
dailyextr$anom_var2 <- dailyextr[,which(colnames(dailyextr) == paste("anom_", var2name, sep=""))]

dailyextr <- dailyextr[c("district", "date", "var1", "var2", "anom_var1", "anom_var2")]
dailyextr$district <- simplifynames(dailyextr$district)
# fill in missing and future climatological data
totaldailyextr <- expand.grid(district=unique(dailyextr$district),
                              date=seq(from=as.Date(paste((minmosqyear-1), "-01-01", sep=""),
                                                    "%Y-%m-%d"),
                                       to=maxdesiredhumandate,
                                       by=1))
dailyextr <- merge(x=totaldailyextr, y=dailyextr,
                   by.x=c("district","date"),
                   by.y=c("district","date"),
                   all.x=TRUE)
dailyextr$doy <- as.numeric(format(dailyextr$date, "%j"))

dailyextr <- group_by(dailyextr, district, doy)
districtdoymean <- dplyr::summarize(dailyextr,
                           meanvar1=mean(var1, na.rm=TRUE),
                           meanvar2=mean(var2, na.rm=TRUE))
dailyextr <- ungroup(dailyextr)                           

dailyextr <- left_join(dailyextr, districtdoymean,
                   by=c("district","doy"))

# replace missing with reasonable values
dailyextr$var1[is.na(dailyextr$var1)] <- dailyextr$meanvar1[is.na(dailyextr$var1)]
dailyextr$var2[is.na(dailyextr$var2)] <- dailyextr$meanvar2[is.na(dailyextr$var2)]
dailyextr$anom_var1[is.na(dailyextr$anom_var1)] <- 0
dailyextr$anom_var2[is.na(dailyextr$anom_var2)] <- 0

# garbage collection
rm(districtdoymean)
dailyextr$meanvar1 <- NULL
dailyextr$meanvar2 <- NULL
gc()

# we need the districts to be in lower case to merge with the gridMET data
fullcasemat$district <- simplifynames(fullcasemat$district)

datalagger <- expand.grid(unique(fullcasemat$district),
                          unique(fullcasemat$weekstartdate),
                          seq(from=0, to=laglen-1, by=1))
names(datalagger) <- c("district","date","lag")
datalagger$laggeddate <- datalagger$date-datalagger$lag

datalagger <- left_join(datalagger, dailyextr,
                        by=c("district"="district",
                             "laggeddate"="date"))

# garbage collection
rm(dailyextr)
gc()

# pivot
mean1data <- dcast(datalagger, district + date ~ lag, value.var="var1")
names(mean1data) <- paste("var1_",names(mean1data),sep="")
mean2data <- dcast(datalagger, district + date ~ lag, value.var="var2")
names(mean2data) <- paste("var2_",names(mean2data),sep="")

anom_mean1data <- dcast(datalagger, district + date ~ lag, value.var="anom_var1")
names(anom_mean1data) <- paste("anom_var1_",names(anom_mean1data),sep="")
anom_mean2data <- dcast(datalagger, district + date ~ lag, value.var="anom_var2")
names(anom_mean2data) <- paste("anom_var2_",names(anom_mean2data),sep="")

# garbage collection
rm(datalagger)
gc()

# and put all this lagged info back into the total case matrix
fullcasemat <- merge(x=fullcasemat, y=mean1data,
                     by.x=c("district", "weekstartdate"),
                     by.y=c("var1_district","var1_date"),
                     all.x=TRUE)
fullcasemat <- merge(x=fullcasemat, y=mean2data,
                     by.x=c("district", "weekstartdate"),
                     by.y=c("var2_district","var2_date"),
                     all.x=TRUE)

# turn these into matrices
fullcasemat$var1 <- as.matrix(fullcasemat[,grep(x=colnames(fullcasemat),
                                                pattern="var1_",
                                                fixed=TRUE)])
fullcasemat$var2 <- as.matrix(fullcasemat[,grep(x=colnames(fullcasemat),
                                                pattern="var2_",
                                                fixed=TRUE)])
fullcasemat <- merge(x=fullcasemat, y=anom_mean1data,
                     by.x=c("district", "weekstartdate"),
                     by.y=c("anom_var1_district","anom_var1_date"),
                     all.x=TRUE)
fullcasemat <- merge(x=fullcasemat, y=anom_mean2data,
                     by.x=c("district", "weekstartdate"),
                     by.y=c("anom_var2_district","anom_var2_date"),
                     all.x=TRUE)

# turn these into matrices too
fullcasemat$anom_var1 <- as.matrix(fullcasemat[,grep(x=colnames(fullcasemat),
                                                pattern="anom_var1_",
                                                fixed=TRUE)])
fullcasemat$anom_var2 <- as.matrix(fullcasemat[,grep(x=colnames(fullcasemat),
                                                pattern="anom_var2_",
                                                fixed=TRUE)])

fullcasemat[,grep(x=colnames(fullcasemat), pattern="var1_", fixed=TRUE)] <- NULL
fullcasemat[,grep(x=colnames(fullcasemat), pattern="var2_", fixed=TRUE)] <- NULL
fullcasemat[,grep(x=colnames(fullcasemat), pattern="anom_var1_", fixed=TRUE)] <- NULL
fullcasemat[,grep(x=colnames(fullcasemat), pattern="anom_var2_", fixed=TRUE)] <- NULL

# import strata
fullcasemat <- merge(x=fullcasemat, y=strata,
                     by.x="district", by.y="district",
                     all.x=TRUE)

# create lag matrix
fullcasemat$lag <- fullcasemat$var1
for (curcol in 1:dim(fullcasemat$lag)[2]) {
  
  fullcasemat$lag[,curcol] <- (curcol-1)

}

# create terms for seasonally-varying distributed lag
fullcasemat$doymat <- fullcasemat$lag
fullcasemat$doymat[,] <- fullcasemat$doy

# garbage collection
rm(mean1data)
rm(mean2data)
gc()

# include the mosquito summary statistic
stratayearmosq <- randeffs
stratayearmosq <- stratayearmosq[c("stratayear","mosqinfect")]
names(stratayearmosq) <- c("stratayear","MIRsummarystat")

fullcasemat$year <- as.numeric(format(fullcasemat$weekstartdate, "%Y"))
fullcasemat$stratayear <- paste(fullcasemat$strata, fullcasemat$year, sep=":")
fullcasemat$year <- NULL

fullcasemat <- merge(x=fullcasemat, y=stratayearmosq,
                     by.x="stratayear", by.y="stratayear",
                     all.x=TRUE)

# calculate missing MIRsummarystat
stratayearmosq$strata <- substr(stratayearmosq$stratayear, 1, 3)
tempdf <- aggregate(stratayearmosq$MIRsummarystat,
                    by=list(stratayearmosq$strata),
                    FUN=mean,
                    na.rm=TRUE)
names(tempdf) <- c("strata","MIRsummarystat2")

fullcasemat <- merge(x=fullcasemat, y=tempdf,
                     by.x="strata", by.y="strata",
                     all.x=TRUE)
fullcasemat$MIRsummarystat[is.na(fullcasemat$MIRsummarystat)] <- fullcasemat$MIRsummarystat2[is.na(fullcasemat$MIRsummarystat)]

fullcasemat$strata <- NULL
fullcasemat$stratayear <- NULL
fullcasemat$MIRsummarystat2 <- NULL

fullcasemat <- ungroup(fullcasemat)
```

```{r humanreg, echo=FALSE, include=FALSE}
# make sure district is a factor before modeling
fullcasemat$district <- factor(fullcasemat$district)

# get list of models and run them
preds <- data.frame()
modelevals <- data.frame()
for (curmodel in modelnames) {
  
  thisformula <- modelformulas[c(curmodel)]
  myform <- as.formula(thisformula)
  
  # main human risk model
  cl <- makeCluster(detectCores(logical=FALSE)-1)
  firstreg  <- bam(formula=myform,
                   family=binomial(), data=fullcasemat,
                   subset=modeled==1,
                   cluster=cl)
  stopCluster(cl)
  
  # predict on this model
  fullcasemat$pred <- predict(firstreg, newdata=fullcasemat, newlevels=TRUE, type="response")

  # get data frame of predictions from this model
  tempdf <- data.frame(weekstartdate = fullcasemat$weekstartdate,
                       district = fullcasemat$district,
                       anycases = fullcasemat$anycases,
                       totalcases = fullcasemat$totalcases,
                       observed = fullcasemat$observed,
                       modeled = fullcasemat$modeled,
                       pred = fullcasemat$pred,
                       model = curmodel)
  preds <- bind_rows(preds, tempdf)
  
  # evaluate this model fit
  tempdf <- fullcasemat[fullcasemat$modeled == 1,]
  tempdf <- data.frame(auc = round_any(roc(response = tempdf$anycases,
                                 predictor = tempdf$pred,
                                 na.rm=TRUE,
                                 auc=TRUE)$auc, 0.01),
                       aic = round_any(AIC(firstreg)[1], 0.01),
                       model = curmodel)
  modelevals <- bind_rows(modelevals, tempdf)

}
```

```{r humanregplot, echo=FALSE}
preds$weeknum <- as.numeric(format(preds$weekstartdate, "%U"))

# figure out in which weeks we actually have cases, for the purpose of graphing
tempdf <- preds[preds$weeknum >= (humanminobsweek-1),]
tempdf <- tempdf[tempdf$weeknum <= (humanmaxobsweek+1),]

tempdf <- group_by(tempdf, weekstartdate, model)
tempdf <- dplyr::summarize(tempdf,
                    obs=mean(anycases, na.rm=TRUE),
                    est=mean(pred, na.rm=TRUE),
                    week=mean(weeknum, na.rm=TRUE))

tempdf$newwe <- (tempdf$week - humanminobsweek) / (humanmaxobsweek - humanminobsweek + 1)
tempdf$year <- as.numeric(format(tempdf$weekstartdate, "%Y"))
tempdf$newdate <- tempdf$year + tempdf$newwe

# plot just this year
preds$year <- as.numeric(format(preds$weekstartdate, "%Y"))
tempdf2 <- preds[preds$year == maxmosqyear,]
```
```{r fig.width=7, fig.height=4, echo=FALSE, warnings=FALSE}
thisplot <- ggplot(tempdf) + geom_line(aes(x=newdate,
                               y=obs, group=model)) +
  geom_line(aes(x=newdate, y=est, group=model, color=model, linetype=model)) +
  ggtitle("Statewide model predictions") +
  xlab("") + ylab("") +
  scale_x_continuous(breaks=seq(from=minmosqyear,to=(maxmosqyear+1),by=1),
                     labels=c(seq(from=minmosqyear, to=maxmosqyear, by=1), ""),
                     limits=c((minmosqyear+0.125),(maxmosqyear+1))) +
  ylab("Proportion of districts positive") +
  theme(panel.grid.minor.x=element_blank()) +
  theme(axis.text.x = element_text(hjust=-0.225)) +
  theme(legend.position="bottom")
plot(thisplot)
thisplot2 <- ggplot(tempdf2) +
  geom_line(aes(x=newdate, y=est, group=model, color=model, linetype=model)) +
  ggtitle("Statewide model predictions") +
  xlab("") + ylab("") +
  ylab("Proportion of districts positive") +
  theme(panel.grid.minor.x=element_blank()) +
  theme(axis.text.x = element_text(hjust=-0.225)) +
  theme(legend.position="bottom")
plot(thisplot2)
```

Model fit statistics are shown below.

```{r, echo=FALSE, include=TRUE}
kable(modelevals[c("model", "aic", "auc")])
```

Estimates for the week in question are shown below.

```{r curyearplot, include=TRUE, echo=FALSE, fig.width=7, fig.height=3.5}

tempdf <- preds
tempdf <- group_by(tempdf, weekstartdate, model)
tempdf <- dplyr::summarize(tempdf,
                    obs=mean(anycases, na.rm=TRUE),
                    est=mean(pred, na.rm=TRUE))
tempdf$year <- as.numeric(format(tempdf$weekstartdate, "%Y"))
tempdf$month <- as.numeric(format(tempdf$weekstartdate, "%m"))
tempdf$weeknum <- as.numeric(format(tempdf$weekstartdate, "%U"))

tempdf <- tempdf[tempdf$weeknum >= humanminobsweek,]
tempdf <- tempdf[tempdf$weeknum <= humanmaxobsweek,]

thisyear <- tempdf[tempdf$year == maxmosqyear,]

tempdf <- bind_rows(thisyear,
                    comparison1,
                    comparison2)

tempdf$est[tempdf$year == compyear1] <- tempdf$obs[tempdf$year == compyear1]
tempdf$est[tempdf$year == compyear2] <- tempdf$obs[tempdf$year == compyear2]
tempdf$year <- factor(tempdf$year)

tempdf2 <- thisyear[thisyear$weekstartdate >= weekinquestionSun,]
tempdf2 <- tempdf2[1:length(modelnames),]

tempdf2$totalestimated <- round_any(tempdf2$est * length(district_shapes), 0.1)
tempdf2$est <- paste(round_any(100*tempdf2$est, 0.1), "%", sep="")

kable(tempdf2[c("model", "est", "totalestimated")],
      col.names=c("model", "prop. positive", "districts positive"))
```

```{r plotblah, include=TRUE, echo=FALSE, fig.width=7, fig.height=3.5}
# thisplot <- ggplot(tempdf) + geom_line(data=tempdf, aes(x=weekstartdate,
#                            y=est,
#                            color=year,
#                            linetype=year)) +
#   geom_point(data=tempdf2, aes(x=weekstartdate, y=est, color=model, linetype=model), color="red", size=4)+
#   xlab("") + ylab("") +
#   scale_x_date(date_labels="%b", date_breaks="1 month",
#                limits=c(as.Date(paste(maxmosqyear, "-05-01", sep=""), "%Y-%m-%d"),
#                         as.Date(paste(maxmosqyear, "-11-15", sep=""), "%Y-%m-%d")),
#                labels=c("May","Jun","Jul","Aug","Sep","Oct","Nov","")) +
#   ylab("Proportion of districts positive") +
#   theme(panel.grid.minor.x=element_blank())
#   #scale_linetype_manual(values=c(3,2,1)) +
#   #scale_color_manual(values=c("black","black","red"))
# thisplot1 <- thisplot + ggtitle(paste("Estimates for ",
#                 maxmosqyear, " compared to observations in ", compyear1, " and ", compyear2,
#                 "\nwith week beginning ", weekinquestionSun, " highlighted", sep="")) +
#   theme(axis.text.x = element_text(hjust=-1.25))
# plot(thisplot1)
```

```{r echo=FALSE}
preds$year <- as.numeric(format(preds$weekstartdate, "%Y"))

preds <- group_by(preds, year, model)
yearlies <- dplyr::summarise(preds,
                             totpos = sum(anycases, na.rm=TRUE),
                             totest = sum(pred,     na.rm=TRUE),
                             totcases = sum(totalcases, na.rm=TRUE))

yearlies$weight <- 1

thisyear <- yearlies[yearlies$year == maxmosqyear,]
prevyears <- yearlies[yearlies$year < maxmosqyear,]

thisyear$totpos <- thisyear$totest
prevyears <- bind_rows(prevyears, expand.grid(totpos=0,
                                              totcases=0,
                                              weight=100,
                                              model=unique(prevyears$model)))
# make sure model is a factor 
prevyears$model <- factor(prevyears$model)

# figure out relationship between positivity and total cases
relationship <- gam(totcases ~ s(totpos, by=model), weights=weight, data=prevyears)

predframe <- expand.grid(totpos = seq(from=0,
                                     to=max(prevyears$totpos, na.rm=TRUE),
                                     length.out=50),
                         model=unique(prevyears$model))
predframe$totcases <- predict(relationship, newdata = predframe)
thisyear$totcases <- predict(relationship, newdata = thisyear)

ggplot() + geom_line(data=predframe, aes(x=totpos, y=totcases), color="red", linetype=2) +
  geom_abline(slope=1, intercept=0, color="grey", linetype=2) +
  geom_point(data=thisyear, aes(x=totpos, y=totcases), color="red", size=5) +
  geom_point(data=yearlies, aes(x=totpos, y=totcases)) +
  xlab("positive county-weeks in a year") + ylab("total cases that year") +
  facet_wrap(~model, ncol=2)

thisyear$totest <- round_any(thisyear$totest, 0.1)
thisyear$totcases <- round_any(thisyear$totcases, 0.1)
kable(thisyear[c("model", "totest", "totcases")],
      col.names=c("model", "est. positives", "total est. cases"))
```



## Results for `r weekinquestionSun` to `r format(weekinquestionSat, "%m-%d")`

We visualize the raw estimated risk for `r weekinquestion` below. If a district is darkest blue, then we estimate that there should be no human cases reported for this district, during this week. If a district is brightest red, we are certain that there will be at least one human case reported for this district, during this week.

```{r shapefile, include=FALSE, echo=FALSE, warnings=FALSE}
district_shapes <- readShapePoly(districtshapefile)
district_shapes$NAME <- simplifynames(district_shapes$NAME)
crs(district_shapes) <- "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80     +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
projected_districts <- spTransform(district_shapes, crs("+proj=longlat +datum=WGS84 +no_defs"))
projected_districts@data$id = rownames(projected_districts@data)
projected_districts.df <- tidy(projected_districts)
projected_districts.df <- left_join(projected_districts.df, projected_districts@data, by="id")
projected_districts.df$district <- simplifynames(projected_districts.df$NAME)

# get this week's predictions
thisweek <- preds[preds$weekstartdate >= weekinquestion,]
thisweek <- thisweek[thisweek$weekstartdate == min(thisweek$weekstartdate, na.rm=TRUE),]
thisweek <- thisweek[c("model", "district", "pred")]

tempdf2 <- data.frame()
for (curmodel in unique(thisweek$model)) {

  tempdf <- projected_districts.df
  tempdf <- left_join(tempdf, thisweek, by="district")
  tempdf$pred[is.na(tempdf$pred)] <- min(tempdf$pred, na.rm=TRUE)
  tempdf$model <- curmodel
  
  tempdf2 <- bind_rows(tempdf2, tempdf)

}
projected_districts.df <- tempdf2
```
```{r shapefile2, include=TRUE, echo=FALSE, fig.width=7, fig.height=3.5}
thisplot <- ggplot(projected_districts.df) +
      aes(long,lat,fill=pred,group=group,id=id,guides=FALSE) +
      geom_polygon() + xlab("") + ylab("") +
      geom_path(color="black") +
      theme(legend.position="bottom") +
      scale_fill_distiller(palette = "Spectral", limits=c(0,1),
                                                 breaks = c(0,1),
                                                 labels = c("Will definitely not\nreport any cases",
                                                            "Will definitely\nreport some cases"),
                                                     name = "") +
      coord_map() + ggtitle(paste("Estimate for week beginning ",
                            weekinquestionSun,
                            sep="")) +
        theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
            axis.ticks = element_blank(), axis.text.x = element_blank(),
            axis.text.y = element_blank(), axis.title.x=element_blank(),
            axis.title.y = element_blank(),
            legend.position="bottom",
            legend.key.width=unit(1, "cm"),
            legend.key.height=unit(0.25,"cm")) +
  facet_wrap(~model, ncol=2)
plot(thisplot)
```

This map indicates whether probabilities reported in the previous map are higher (red) than average, lower (blue) than average, or right about normal (yellow) compared to the same week in previous years.

```{r riskcalcs, include=TRUE, echo=FALSE, fig.width=7, fig.height=3.5}
# thisweek <- fullcasemat[fullcasemat$weekstartdate >= weekinquestion,]
# thisweek <- thisweek[thisweek$weekstartdate == min(thisweek$weekstartdate, na.rm=TRUE),]
# thisweek <- thisweek[c("district", "pred", "doy")]
# 
# approxdoy <- thisweek$doy[1]
# 
# fullcasemat$year <- as.numeric(format(fullcasemat$weekstartdate, "%Y"))
# 
# doypreds <- data.frame()
# for (curyear in unique(fullcasemat$year)) {
#   
#   for (curdistrict in unique(fullcasemat$district)) {
#     
#     thisdf <- fullcasemat[fullcasemat$year == curyear,]
#     thisdf <- thisdf[thisdf$district == curdistrict,]
#     
#     if(sum(!is.na(thisdf$pred)) > 1) {
#     
#       tempdf <- data.frame(district = curdistrict,
#                            year = curyear,
#                            pred = approx(x=thisdf$doy,
#                                         y=thisdf$pred,
#                                         xout=approxdoy)$y)
#       
#       doypreds <- bind_rows(doypreds, tempdf)
#       
#     }
#     
#   }
#   
# }
# 
# doypreds2 <- data.frame()
# for (curdistrict in unique(doypreds$district)) {
# 
#   tempdf <- doypreds[doypreds$district == curdistrict,]
#   tempdf$percentile <- rank(tempdf$pred, ties.method="random") / length(tempdf$pred)
#   
#   doypreds2 <- bind_rows(doypreds2, tempdf)
#   
# }
# doypreds <- doypreds2
# rm(doypreds2)
# 
# riskalpha <- 0.25
# doypreds$riskcategory <- " About average    "
# doypreds$riskcategory[doypreds$percentile <= riskalpha/2] <- " Lower than usual    "
# doypreds$riskcategory[doypreds$percentile >= 1-(riskalpha/2)] <- " Higher than usual    "
# doypredscurrent <- doypreds[doypreds$year == as.numeric(format(weekinquestion, "%Y")),]
# projected_districts.df <- left_join(projected_districts.df, doypredscurrent,
#                                    by="district")
# projected_districts.df$riskcategory[is.na(projected_districts.df$riskcategory)] <- " Not able to model    "
# thisplotrisk <- ggplot(projected_districts.df) +
#       aes(long,lat,fill=riskcategory,group=group,guides=FALSE) +
#       geom_polygon() + 
#       geom_path(color="black") +
#       coord_map() + 
#       ggtitle("") +
#       theme(text=element_text(size=15)) +
#       theme(plot.title=element_text(size=15),
#             legend.key=element_rect(fill="white")) +
#       theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
#             axis.ticks = element_blank(), axis.text.x = element_blank(),
#             axis.text.y = element_blank(), axis.title.x=element_blank(),
#             axis.title.y = element_blank(),
#             legend.position="bottom",
#             legend.key.width=unit(1, "cm"),
#             legend.key.height=unit(0.5,"cm")) +
#       theme(legend.direction="vertical") +
#       scale_fill_manual(name=paste("Risk for ", weekinquestionSun, " to ",
#                                    format(weekinquestionSat, "%m-%d"), sep=""),
#                         values=c(" Lower than usual    "="lightblue",
#                                  " About average    "="yellow",
#                                  " Higher than usual    "="red",
#                                  " Not able to model    "="grey"))
# 
# 
# plot(thisplotrisk)
```
\newpage

## District names

It is possible that district names in the human, mosquito, or weather data might disagree with the names found in the district shapefile. We have chosen the shapefile to unify all of the various data sources, so the human, mosquito, and weather data files should be updated to match these. Typically, check the TIGER shapefiles or census for standardized names.

```{r diagnostics, include=FALSE, echo=FALSE}
humannotinshapefile <- diagnostic_humandistricts[!(diagnostic_humandistricts %in% diagnostic_shapefiledistricts)]
if (length(humannotinshapefile) == 0) { humannotinshapefile <- "none" }

mosquitonotinshapefile <- diagnostic_mosquitodistricts[!(diagnostic_mosquitodistricts %in% diagnostic_shapefiledistricts)]
if (length(mosquitonotinshapefile) == 0) { mosquitonotinshapefile <- "none" }

weathernotinshapefile <- diagnostic_weatherdistricts[!(diagnostic_weatherdistricts %in% diagnostic_shapefiledistricts)]
if (length(weathernotinshapefile) == 0) { weathernotinshapefile <- "none" }
```

There are `r length(diagnostic_shapefiledistricts)` districts in the shapefile. This is the maximum number of districts ArboMAP will recognize in the human, mosquito, or weather data.

There are `r length(diagnostic_humandistricts)` districts in the human WNV data. If some districts never reported cases, this number may be less than the number of districts in the shapefile. If there are more, there are likely misspellings in the human data file. Human districts not found in the district shapefile: `r humannotinshapefile`.

There are `r length(diagnostic_mosquitodistricts)` districts in the mosquito WNV data. If some districts never reported mosquito data, this number may be less than the number of districts in the shapefile. Mosquito districts not found in the district shapefile: `r mosquitonotinshapefile`.

There are `r length(diagnostic_weatherdistricts)` districts in the mosquito WNV data. If these data were downloaded with the GEE app, they should match the shapefile districts exactly. Weather districts not found in the district shapefile: `r weathernotinshapefile`.


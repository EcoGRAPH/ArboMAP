---
title: "ArboMAP: Arbovirus Modeling and Prediction   \nto Forecast Mosquito-Borne Disease Outbreaks"
author: "Summary of Model Outputs (v1.0)   \nJustin K. Davis and Michael C. Wimberly  \n(justin.k.davis@sdstate.edu, michael.wimberly@sdstate.edu)  \nGeospatial Sciences Center of Excellence, South Dakota State University"
date: "Updated `r format(Sys.time(), '%B %d, %Y')`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# define some helpful functions
'%!in%' <- function(x,y)!('%in%'(x,y))
round_any = function(x, accuracy, f=round){f(x/accuracy) * accuracy}
options(warn=-1)
```

```{r namefunction, include=FALSE}
simplifynames <- function(priornames=NULL) {

  # convert to lower case
  priornames <- tolower(priornames)
  
  # remove spaces
  priornames <- sub(pattern=" ", replacement="", x=priornames, fixed=TRUE)
  
  # remove county and parish
  priornames <- sub(pattern="county", replacement="", x=priornames, fixed=TRUE)
  priornames <- sub(pattern="parish", replacement="", x=priornames, fixed=TRUE)

  # return names
  return(priornames)
  
}
```

```{r libraries, include=FALSE}
packages <- c("reshape2", "ggplot2", "gridExtra",
              "lme4","pracma","dplyr","maptools",
              "raster","spdep","mgcv","sp","rgdal",
              "GISTools","data.table","splines","maps",
              "broom","mapproj", "Hmisc")
for (package in packages) {
    if (!require(package, character.only=T, quietly=T)) {
        install.packages(package)
        library(package, character.only=T)
    }
}
```

```{r setoptions, include=FALSE, echo=FALSE}

# where do we want the outputs?
graphicoutputdir <- ".\\graphical outputs\\"
fullcasematoutputdir <- ".\\case matrix with estimates\\"
mosqmatoutputdir <- ".\\mosquito matrix with estimates\\"

# where are the human data located?
# this is an example of where we happen to store our actual data
#humandatafile <- ".\\human case data\\simulated human case data.csv"

# but this directs the program to use simulated human case data that come with ArboMAP
humandatafile <- ".\\human case data\\simulated human case data.csv"

# what is the date of the last human case we're willing to believe?
# probably, cut this off at the end of last year
# DO NOT use any human cases from the year you're modeling
maxobservedhumandate <- as.Date("2017-12-31", "%Y-%m-%d")

# which week are we producing the graphs for?
weekinquestion <- as.Date("2018-08-26", "%Y-%m-%d")

# where are the gridmet csv files stored?
gridmetpathstr <- ".\\gridMet\\"
# what is the name of the summary file to be created?
gridmetsummaryfile <- "gridmet internal summary.csv"

# where are the mosquito test files located?
# this is an example of where we happen to store our actual mosquito data
#acttestfile <- "D:\\work\\git\\WNV\\packaged WNV\\mosquito\\active_testing.csv"
#arctestfile <- "D:\\work\\git\\WNV\\packaged WNV\\mosquito\\archive_testing.csv"

# but this directs the program to use simulated mosquito data that come with ArboMAP
#arctestfile <- ".\\mosquito data\\simulated archive_test.csv"
mosqfile <- ".\\mosquito data\\simulated mosquito tests.csv"

# which county stratification scheme are we using?
stratafile <- ".\\strata\\17-04-20 - classified strata - classic.csv"

# where is the countyshapefile
countyshapefile <- ".\\shapefile\\cb_2014_us_county_5m - in EPSG 5070 - only SD.shp"

# to which two other years do we want to compare the current year's predictions?
compyear1 <- 2012
compyear2 <- 2017




# probably don't want to modify what follows, but you have some options if you're comfortable

# makes sure we round to the previous Sunday, so that this week is included
weekinquestionSun <- weekinquestion - (as.numeric(strftime(weekinquestion, '%u')) %% 7)
weekinquestionSat <- weekinquestionSun + 6
weekinquestionSunstr <- strftime(weekinquestionSun, '%A')
weekinquestionSatstr <- strftime(weekinquestionSat, '%A')

# figure out which year this is and begin all weeks on Sunday
maxmosqyear <- as.numeric(format(weekinquestion, "%Y"))
maxdesiredhumandate <- as.Date(paste(maxmosqyear,
                                     "-12-31",sep=""))
maxdesiredhumandate <- maxdesiredhumandate - (as.numeric(strftime(maxdesiredhumandate, '%u')) %% 7)
maxdesiredhumandatestr <- strftime(maxdesiredhumandate, '%A')

# make sure the max desired human date is no earlier than the week in question
# otherwise, there will be no predictions for the week in question
maxdesiredhumandate <- max(weekinquestionSun+7, maxdesiredhumandate)

# set up lag and regression information
laglen   <- 181
dlagdeg  <- 8
```

# Data used for predictions
## Weather data

```{r gridmetload, include=FALSE, echo=TRUE}
# load and concat files
gridmetlist <- list.files(path=gridmetpathstr, pattern="(.csv)", recursive=FALSE)
gridmet <- data.frame()
for (i in 1:length(gridmetlist)) {
  
  if (gridmetlist[[i]] != gridmetsummaryfile) {
  
    tempdf <- read.csv(paste(gridmetpathstr, gridmetlist[[i]], sep="")) 
    gridmet <- bind_rows(gridmet, tempdf)  
    
  }
  
}
gridmet$date <- as.Date(paste(gridmet$year,
                              gridmet$doy,
                              sep="-"),
                        "%Y-%j")

# get rid of duplicated rows
gridmet$fipsdate <- paste(gridmet$Fips, gridmet$date)
gridmet <- subset(gridmet, !duplicated(gridmet$fipsdate))
gridmet$Fipsdate <- NULL

# plot normals and this year
gridmet <- group_by(gridmet,
                    doy)
doymet  <- dplyr::summarize(gridmet,
                     med_tmeanc = quantile(tmeanc, probs=0.50, na.rm=TRUE),
                     med_rmean  = quantile(rmean,  probs=0.50, na.rm=TRUE),
                     med_vpd    = quantile(vpd,    probs=0.50, na.rm=TRUE),
                     max_tmeanc = max(tmeanc, na.rm=TRUE),
                     max_rmean  = max(rmean,  na.rm=TRUE),
                     max_vpd    = max(vpd,    na.rm=TRUE),
                     min_tmeanc = min(tmeanc, na.rm=TRUE),
                     min_rmean  = min(rmean,  na.rm=TRUE),
                     min_vpd    = min(vpd,    na.rm=TRUE))
gridmet <- ungroup(gridmet)

thisyear <- max(gridmet$year, na.rm=TRUE)
thisyear <- subset(gridmet, year == thisyear)
thisyear <- group_by(thisyear, doy)
thisyear <- dplyr::summarize(thisyear,
                      med_tmeanc = quantile(tmeanc, probs=0.50, na.rm=TRUE),
                      med_rmean  = quantile(rmean,  probs=0.50, na.rm=TRUE),
                      med_vpd    = quantile(vpd,    probs=0.50, na.rm=TRUE),
                      max_tmeanc = max(tmeanc, na.rm=TRUE),
                      max_rmean  = max(rmean,  na.rm=TRUE),
                      max_vpd    = max(vpd,    na.rm=TRUE),
                      min_tmeanc = min(tmeanc, na.rm=TRUE),
                      min_rmean  = min(rmean,  na.rm=TRUE),
                      min_vpd    = min(vpd,    na.rm=TRUE))

tempdf <- left_join(doymet, thisyear, by="doy")
tempdf <- tempdf[!is.na(tempdf$med_tmeanc.x),]

meantemp.x <- round(mean(tempdf$med_tmeanc.x, na.rm=TRUE), 1)
meantemp.y <- round(mean(tempdf$med_tmeanc.y, na.rm=TRUE), 1)
meanvapd.x <- round(mean(tempdf$med_vpd.x, na.rm=TRUE), 1)
meanvapd.y <- round(mean(tempdf$med_vpd.y, na.rm=TRUE), 1)
```

Weather data from the gridMET data set range from `r min(gridmet$date, na.rm=TRUE)` to `r max(gridmet$date, na.rm=TRUE)`. Below are graphs of statewide daily averages of temperature and the vapor pressure deficit. The min/max/median for all years are in grey, and observations from this year are in red.

Higher temperatures typically mean higher risk of WNV. Since the beginning of this year, the average statewide temperature in `r maxmosqyear` has been `r meantemp.y`$^{\circ}$C, compared to `r meantemp.x`$^{\circ}$C in all years. The vapor pressure deficit in `r maxmosqyear` has been `r meanvapd.x` kPa, compared to `r meanvapd.y` kPa in all years. Lower vapor pressure deficit typically means more risk of WNV, because there is more moisture in the air, which increases mosquito activity. 

```{r gridmetplots, fig.width=7, fig.height=5, echo=FALSE}
plot1 <- ggplot() + geom_line(data=doymet, aes(x=doy, y=med_tmeanc)) +
  geom_ribbon(data=doymet, aes(x=doy, ymin=min_tmeanc, ymax=max_tmeanc), alpha=0.3) +
  geom_line(data=thisyear, aes(x=doy, y=med_tmeanc), color="red", size=1) +
  xlab("Day of the year") + ylab("Statewide temp (deg C)") +
  ggtitle(paste("Temperature in ",
                max(gridmet$year, na.rm=TRUE),
                sep=""))
plot2 <- ggplot() + geom_line(data=doymet, aes(x=doy, y=log(med_vpd+1))) +
  geom_ribbon(data=doymet, aes(x=doy, ymin=log(min_vpd+1), ymax=log(max_vpd+1)), alpha=0.3) +
  geom_line(data=thisyear, aes(x=doy, y=log(med_vpd+1)), color="red", size=1) +
  ggtitle(paste("Vapor pressure deficit in ",
                max(gridmet$year, na.rm=TRUE),
                " (higher means drier)",
                sep="")) +
  xlab("Day of the year") + ylab("Vapor pressure deficit (log scale)")
grid.arrange(plot1, plot2, nrow=2)
# figure out which fips is which county
gridmet <- left_join(gridmet,
                     county.fips,
                     by=c("Fips"="fips"))
gridmet$county <- sapply(strsplit(gridmet$polyname, ","), "[[", 2)

# simplify the county names
gridmet$county <- simplifynames(gridmet$county)

# put aside this set for use in the gression
dailyextr <- gridmet
```
```{r silentsavegridmet, include=FALSE, echo=FALSE}
ggsave(paste(graphicoutputdir,
             "temperature.png",
             sep=""), plot1)
ggsave(paste(graphicoutputdir,
             "vapor pressure deficit.png",
             sep=""), plot2)
```

\newpage
## Mosquito infection data

```{r mosquito, echo=FALSE} 

mosqdat <- read.csv(mosqfile, stringsAsFactors=FALSE)
names(mosqdat) <- c("county", "col_date","wnv_result","pool_size", "species")

#actmosq <- read.csv(acttestfile, stringsAsFactors=FALSE)
#arcmosq <- read.csv(arctestfile, stringsAsFactors=FALSE)
#actmosq <- actmosq[c("Collection.Date","Species","County","WNV.Result","Number.in.Pool")]
#names(actmosq) <- c("col_date","species","county","wnv_result","pool_size")
#actmosq$wnv_result[actmosq$wnv_result == "Positive"] <- 1
#actmosq$wnv_result[actmosq$wnv_result == "Negative"] <- 0
#actmosq$wnv_result <- as.numeric(actmosq$wnv_result)
#arcmosq <- arcmosq[c("Collection.Date","Species.Old","County","Trap","WNV.Result","Number.in.Pool")]
#names(arcmosq) <- c("col_date","species","county","trap","wnv_result","pool_size")
# # fix some of the counties in 2016, 2017
# arcmosq$date <- as.Date(arcmosq$col_date, "%m/%d/%Y")
# arcmosq$year <- as.numeric(format(arcmosq$date, "%Y"))
# arcmosq <- arcmosq[!is.na(arcmosq$year),]
# arcmosq$county[arcmosq$year == 2017] <- arcmosq$trap[arcmosq$year == 2017]
# arcmosq$county[arcmosq$year == 2016] <- arcmosq$trap[arcmosq$year == 2016]
# arcmosq$year <- NULL
# arcmosq$date <- NULL
# arcmosq$trap <- NULL

wnv <- mosqdat
rm(mosqdat)

#wnv <- bind_rows(arcmosq, actmosq)
wnv$col_date <- as.Date(wnv$col_date, "%m/%d/%Y")
wnv$year <- as.numeric(format(wnv$col_date, "%Y"))

```


```{r mosquito222, echo=FALSE}
# convert county to factor
wnv$county <- simplifynames(wnv$county)
wnv$county <- factor(wnv$county)

# convert date to a date object
wnv$col_date <- as.Date(wnv$col_date, '%m/%d/%Y')

# figure out how many rows we start with
nrow1 <- nrow(wnv)

# clean the data
# retain only those in 2004 onward
wnv <- wnv[wnv$year >= 2004,]

# create some variables we can use to filter
wnv$col_year <- as.numeric(format(wnv$col_date, "%Y"))
wnv$doy      <- as.numeric(format(wnv$col_date, "%j"))
wnv$weeknum  <- as.numeric(format(wnv$col_date, "%U"))
wnv <- wnv[which(wnv$species == "Culex tarsalis"),]
wnv$species <- NULL

# fix some of the bad county names, delete what we can't use
wnv <- wnv[which(wnv$county %!in% c("doh",
                                    "doh-withers",
                                    "mitchell-carlson",
                                    "unknown",
                                    "")),]
wnv$county <- factor(wnv$county)
wnv$county <- droplevels(wnv$county)

# figure out which years we're modeling
minmosqyear <- min(wnv$year, na.rm=TRUE)

# get rid of those which don't have a result
wnv <- wnv[which(!is.na(wnv$wnv_result)),]
wnv <- wnv[which(!is.na(wnv$doy)),]

# delete anything before a certain day
wnv <- wnv[which(wnv$doy >= 100),]
# delete anything after a certain day
wnv <- wnv[which(wnv$doy <= 212),]

# after cleaning, how many do we have?
nrow2 <- nrow(wnv)
nrow3 <- nrow(wnv[wnv$year == maxmosqyear,])

tempdf <- wnv[wnv$year == maxmosqyear,]
tempdf <- tempdf[!is.na(tempdf$wnv_result),]
wnvdenominator <- nrow(tempdf)
wnvnumerator <- nrow(tempdf[tempdf$wnv_result == 1,])

numpos <- wnvnumerator
perpos <- 100*round(wnvnumerator/wnvdenominator, 3)
```

There are `r nrow2` samples in the mosquito testing database. For `r maxmosqyear`, there are `r nrow3` tested pools, with `r numpos` (`r perpos`%) positive. The estimated risk of human infection due to the early-season mosquito infection growth rate is shown below. Higher means that WNV is spreading more rapidly among mosquitoes, and more human cases should be expected. The regions are mapped below.

```{r mosquito2, fig.width=7, fig.height=3, echo=FALSE}
# import county identifiers
strata <- read.csv(stratafile)
strata$county <- simplifynames(strata$NAME)
strata <- strata[c("county", "strata")]
wnv <- merge(x=wnv, y=strata,
             by.x="county",
             by.y="county",
             all.x=TRUE)

# figure out how many distinct counties we have left
countylist           <- data.frame(county=unique(wnv$county))
distinctcounties     <- length(unique(wnv$county))
countylist$countynum <- seq(from=1, to=distinctcounties, by=1)
wnv <- merge(x=wnv, y=countylist,
             by="county",
             all=TRUE)

# create a variable that at least has a little chance of being orthogonal to 1.
wnv$dminus <- wnv$doy - mean(wnv$doy, na.rm=TRUE)

# make sure all the observations have a stratum and year
wnv <- wnv[!is.na(wnv$strata),]
wnv <- wnv[!is.na(wnv$year),]

# run a random effect model on orthogonalized data
infectglm <- glmer(wnv_result ~ 1+dminus+
                    (0+1|year) +
                    (0+dminus|year) +
                    (0+1|strata:year) + 
                    (0+dminus|strata:year),
                  family=binomial(),
                  data=wnv)

wnv$est <- predict(infectglm, newdata=wnv, type="response")
write.csv(x=wnv, file=paste(mosqmatoutputdir,
                            "mosqmatrix.csv",
                            sep=""))

# predict random effects for all years
# dminus cannot be set to simply 0 - we have to 
randeffs <- expand.grid(strata=unique(wnv$strata),
                        year=minmosqyear:maxmosqyear,
                        dminus=0.00001)
randeffs <- randeffs[which(!is.na(randeffs$strata)),]
# if you don't allow new levels, the most recent year might not have an estimate
randeffs$mosqinfect <- predict(infectglm, newdata=randeffs, allow.new.levels = TRUE)
randeffs$stratayear <- paste(randeffs$strata, randeffs$year, sep=":")
randeffs$adjmosqinfect <- randeffs$mosqinfect - mean(randeffs$mosqinfect,na.rm=TRUE)
randeffs$stratum <- factor(randeffs$strata)
levels(randeffs$stratum)[levels(randeffs$stratum)=="101"] <- "Prairie Couteau"
levels(randeffs$stratum)[levels(randeffs$stratum)=="102"] <- "James River Valley"
levels(randeffs$stratum)[levels(randeffs$stratum)=="103"] <- "Missouri Couteau"
levels(randeffs$stratum)[levels(randeffs$stratum)=="104"] <- "Western SD"
thisplot <- ggplot(randeffs) + geom_line(aes(x=year, y=adjmosqinfect, group=stratum, color=stratum)) +
  geom_abline(slope=0, intercept=0, linetype=2) +
  scale_x_continuous(breaks=minmosqyear:maxmosqyear) +
  theme(axis.text.x=element_text(angle=45, hjust=1),
        panel.grid.minor=element_blank(),
        panel.grid.major.y=element_blank())+
  xlab("") + ylab("Relative risk due to\nmosquito infection growth rate")
plot(thisplot)
```
```{r silentsavemosq, include=FALSE, echo=FALSE}
ggsave(paste(graphicoutputdir,
             "mosquito infection rates.png",
             sep=""), thisplot)


```

```{r humandata, include=FALSE, echo=TRUE}

# import data
human <- read.csv(humandatafile)
begrow <- nrow(human)
human$chardate <- as.character(levels(human$creationdate))[as.numeric(human$creationdate)]
human$creationdate <- as.Date(human$creationdate, "%m/%d/%Y")
human$creationyear <- as.numeric(format(human$creationdate, "%Y"))
human$creationmonth <- as.numeric(format(human$creationdate, "%m"))
# simplify county names
human$county[human$county == "Oglala Lakota County"] <- "Shannon County"
human$county <- simplifynames(human$county)
human$county <- factor(human$county)
human$doy <- as.numeric(format(human$creationdate, "%j"))

# retain only those in the right date range
hWNVminyear <- minmosqyear
hWNVmaxyear <- maxmosqyear-1
human <- human[which((human$creationyear >= hWNVminyear) & (human$creationyear <= hWNVmaxyear)),]

# retain only those in months 5-11
human <- human[which((human$creationmonth >= 5) & (human$creationmonth <= 11)),]

# create the full list of weeks
minobservedhumandate <- min(human$creationdate)

# set up the data frame so that it ends at the maxdesiredhumandate 
filledweeks <- seq(from=maxdesiredhumandate, to=minobservedhumandate, by=-7)

fullcasemat <- expand.grid(sort(unique(human$county)), filledweeks)
names(fullcasemat) <- c("county", "weekstartdate")
head(fullcasemat)
fullcasemat$anycases   <- rep(0, nrow(fullcasemat))
fullcasemat$totalcases <- rep(0, nrow(fullcasemat))
fullcasemat$observed   <- 1*((fullcasemat$weekstartdate >= minobservedhumandate)&
                               (fullcasemat$weekstartdate <= maxobservedhumandate))
for (i in 1:nrow(fullcasemat)) {
  
  thisweekstartdate <- fullcasemat$weekstartdate[i]
  thiscounty        <- fullcasemat$county[i]
  
  tempcases <- human[which(human$county == thiscounty),]
  tempcases <- tempcases[which(tempcases$creationdate >= thisweekstartdate),]
  tempcases <- tempcases[which(tempcases$creationdate <= (thisweekstartdate + 6)),]
  
  fullcasemat$anycases[i] <- 1*(nrow(tempcases) > 0)
  if (nrow(tempcases) > 0) {
    
    fullcasemat$totalcases[i] <- nrow(tempcases)
    
  }
  
}
totcase <- sum(fullcasemat$totalcases, na.rm=TRUE)
anypos  <- sum(fullcasemat$anycases, na.rm=TRUE)

# figure out what percentage of cases we'll likely have seen before the start of this week
weekinquestionSundoy <- as.numeric(format(weekinquestionSun, "%j"))
fullcasemat$doy      <- as.numeric(format(fullcasemat$weekstartdate, "%j"))

tempdf <- fullcasemat[fullcasemat$doy < (weekinquestionSundoy+7),]
observedbefore <- sum(tempdf$totalcases, na.rm=TRUE)
observedtotal  <- sum(fullcasemat$totalcases, na.rm=TRUE)
weekinquestionreformat <- format(weekinquestionSun, "%m-%d")
observedfraction <- 100*round(observedbefore / observedtotal, 2)
```
```{r stratamap, include=FALSE, echo=FALSE}

county_shapes <- readShapePoly(countyshapefile)
# simplify name
county_shapes$county <- simplifynames(county_shapes$NAME)
crs(county_shapes) <- "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80     +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
projected_counties <- spTransform(county_shapes, crs("+proj=longlat +datum=WGS84 +no_defs"))
projected_counties@data$id = rownames(projected_counties@data)
projected_counties.df <- tidy(projected_counties)
projected_counties.df <- left_join(projected_counties.df, projected_counties@data, by="id")

stratamapcsv <- read.csv(stratafile)
stratamapcsv$county <- simplifynames(stratamapcsv$NAME)
stratamapcsv <- stratamapcsv[c("county", "strata")]

projected_counties.df <- left_join(projected_counties.df, stratamapcsv,
                                   by="county")

projected_counties.df$stratum <- factor(projected_counties.df$strata.x)
levels(projected_counties.df$stratum)[levels(projected_counties.df$stratum)=="101"] <- "Prairie Couteau"
levels(projected_counties.df$stratum)[levels(projected_counties.df$stratum)=="102"] <- "James River Valley"
levels(projected_counties.df$stratum)[levels(projected_counties.df$stratum)=="103"] <- "Missouri Couteau"
levels(projected_counties.df$stratum)[levels(projected_counties.df$stratum)=="104"] <- "Western SD"
```
```{r stratmap2, include=TRUE, echo=FALSE, fig.width=7, fig.height=3}
thisplot <- ggplot(projected_counties.df) +
      aes(long,lat,fill=stratum,group=group,id=id,guides=FALSE) +
      geom_polygon() + xlab("") + ylab("") +
      geom_path(color="black") +
      theme(legend.position="bottom") +
      coord_map() + ggtitle("State stratification map") +
        theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
            axis.ticks = element_blank(), axis.text.x = element_blank(),
            axis.text.y = element_blank(), axis.title.x=element_blank(),
            axis.title.y = element_blank(),
            legend.position="right",
            legend.key.width=unit(1, "cm"),
            legend.key.height=unit(0.5,"cm"))
plot(thisplot)
```
```{r silentsave88791122823, include=FALSE, echo=FALSE}
ggsave(paste(graphicoutputdir,
             "strata.png",
             sep=""), thisplot)

```

The following graph shows the estimated growth of positive pools for every year (grey), with `r compyear1` (blue) and `r compyear2` (blue, dashed) selected for comparison, and estimates and observations for `r maxmosqyear` (red). The lines are modeled pool positive rates; the actual statewide positive pool rate for `r maxmosqyear` is shown here on 10-day intervals with dots.

```{r mosqbymo, include=TRUE, echo=FALSE, fig.width=6, fig.height=3}
mosqmopreds <- expand.grid(strata=unique(wnv$strata),
                           year=minmosqyear:maxmosqyear,
                           doy=seq(from=min(wnv$doy, na.rm=TRUE),
                                   to  =max(wnv$doy, na.rm=TRUE), by=1))
mosqmopreds$dminus <- mosqmopreds$doy - mean(wnv$doy, na.rm=TRUE)
mosqmopreds$preds <- predict(infectglm, newdata=mosqmopreds, type="response", allow.new.levels=TRUE)

mosqmopreds <- group_by(mosqmopreds, dminus, year)
mosqmopreds <- dplyr::summarize(mosqmopreds,
                         preds=mean(preds, na.rm=TRUE),
                         doy=mean(doy, na.rm=TRUE))
#mosqmopreds$doy <- round(mosqmopreds$dminus + mean(wnv$doy, na.rm=TRUE), 0)
thisyear1   <- mosqmopreds[mosqmopreds$year == maxmosqyear,]
comparison1 <- mosqmopreds[mosqmopreds$year == compyear1,]
comparison2 <- mosqmopreds[mosqmopreds$year == compyear2,]

thisyeardot <- wnv[wnv$year == maxmosqyear,]
#thisyeardot$rounddoy <- round_any(thisyeardot$doy, 10)
thisyeardot$rounddoy <- cut2(thisyeardot$doy, g=6)
thisyeardot <- group_by(thisyeardot, rounddoy)
thisyeardot <- dplyr::summarize(thisyeardot,
                      meanpos = mean(wnv_result, na.rm=TRUE),
                      meandoy = mean(doy, na.rm=TRUE))
thisplot <- ggplot(data=mosqmopreds) + geom_line(data=mosqmopreds, aes(x=doy, y=preds, group=year),
                                                 color="grey", alpha=0.5) +
  geom_line(data=comparison1, aes(x=doy, y=preds), color="blue") +
  geom_line(data=comparison2, aes(x=doy, y=preds), color="blue", linetype=2) +
  geom_line(data=thisyear1, aes(x=doy, y=preds), color="red") +
  geom_point(data=thisyeardot, aes(x=meandoy, y=meanpos), color="red") +
  xlab("day of the year") + ylab("Cx. tarsalis WNV pool positive rate") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(colour = "black"))
plot(thisplot)
```
```{r include=FALSE, echo=FALSE}
ggsave(paste(graphicoutputdir,
             "mosqinfectgrowthrates.png",
             sep=""), thisplot)
```


## Human data

The predictive model of human WNV was calibrated using `r totcase` historical human cases, not including any cases from `r maxmosqyear`. No cases from `r maxmosqyear` are used to make predictions; the estimates for this year are based solely on weather and mosquito data. Typically, `r observedfraction`% of a year's cases occur before the end of this week in any given year.

# Model results

## Statewide trends

The graphs below show observed statewide risk (black) and estimated risk (red) up to `r maxdesiredhumandatestr` `r maxdesiredhumandate`. Observed risk should be completely zero during the last year - these data are not used in the model, and will only be updated once final human case data are received at the end of the year.

```{r humandata2, echo=TRUE, warnings=FALSE, include=FALSE}
# select which variables we're going to use!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
dailyextr$var1 <- dailyextr$tmeanc
dailyextr$var2 <- dailyextr$vpd
dailyextr <- dailyextr[c("county","date","var1","var2")]
dailyextr$county <- simplifynames(dailyextr$county)
# fill in missing and future climatological data
totaldailyextr <- expand.grid(county=unique(dailyextr$county),
                              date=seq(from=as.Date("2003-01-01", "%Y-%m-%d"),
                                       to=maxdesiredhumandate,
                                       by=1))
dailyextr <- merge(x=totaldailyextr, y=dailyextr,
                   by.x=c("county","date"),
                   by.y=c("county","date"),
                   all.x=TRUE)
dailyextr$doy <- as.numeric(format(dailyextr$date, "%j"))

dailyextr <- group_by(dailyextr, county, doy)
countydoymean <- dplyr::summarize(dailyextr,
                           meanvar1=mean(var1, na.rm=TRUE),
                           meanvar2=mean(var2, na.rm=TRUE))
dailyextr <- ungroup(dailyextr)                           

dailyextr <- left_join(dailyextr, countydoymean,
                   by=c("county","doy"))

dailyextr$var1[is.na(dailyextr$var1)] <- dailyextr$meanvar1[is.na(dailyextr$var1)]
dailyextr$var2[is.na(dailyextr$var2)] <- dailyextr$meanvar2[is.na(dailyextr$var2)]

# BRING OUT YOUR DEAD!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
rm(countydoymean)
dailyextr$meanvar1 <- NULL
dailyextr$meanvar2 <- NULL
gc()

# we need the counties to be in lower case to merge with the gridMET data
fullcasemat$county <- simplifynames(fullcasemat$county)

datalagger <- expand.grid(unique(fullcasemat$county),
                          unique(fullcasemat$weekstartdate),
                          seq(from=0, to=laglen-1, by=1))
names(datalagger) <- c("county","date","lag")
datalagger$laggeddate <- datalagger$date-datalagger$lag

datalagger <- left_join(datalagger, dailyextr,
                        by=c("county"="county",
                             "laggeddate"="date"))

# BRING OUT YOUR DEAD!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
rm(dailyextr)
gc()

# pivot
mean1data <- dcast(datalagger, county + date ~ lag, value.var="var1")
names(mean1data) <- paste("var1_",names(mean1data),sep="")
head(mean1data)

mean2data <- dcast(datalagger, county + date ~ lag, value.var="var2")
names(mean2data) <- paste("var2_",names(mean2data),sep="")
head(mean2data)

# BRING OUT YOUR DEAD!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
rm(datalagger)
gc()

# and put all this lagged info back into the total case matrix
fullcasemat <- merge(x=fullcasemat, y=mean1data,
                     by.x=c("county", "weekstartdate"),
                     by.y=c("var1_county","var1_date"),
                     all.x=TRUE)
fullcasemat <- merge(x=fullcasemat, y=mean2data,
                     by.x=c("county", "weekstartdate"),
                     by.y=c("var2_county","var2_date"),
                     all.x=TRUE)

# BRING OUT YOUR DEAD!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
rm(mean1data)
rm(mean2data)
gc()

lagframe <- data.frame(x=seq(from=1, to=laglen, by=1))
alpha <- 1/4
distlagfunc <- ns(lagframe$x, intercept=TRUE,
                  knots=quantile(lagframe$x,
                                 probs=seq(from=alpha, to=1-alpha, by=alpha),
                                 na.rm=TRUE))
matplot(distlagfunc, type="l")
dlagdeg <- size(distlagfunc)[2]

# create actual distributed lag summaries
band1summaries <- matrix(rep(0, nrow(fullcasemat)*dlagdeg), nrow(fullcasemat), dlagdeg)
band2summaries <- matrix(rep(0, nrow(fullcasemat)*dlagdeg), nrow(fullcasemat), dlagdeg)

names(fullcasemat)
min1index <- which(names(fullcasemat) == "var1_0")
min2index <- which(names(fullcasemat) == "var2_0")
fullcasemat <- data.frame(fullcasemat)
band1temp <- as.matrix(fullcasemat[,(min1index:(min1index+laglen-1))])
band2temp <- as.matrix(fullcasemat[,(min2index:(min2index+laglen-1))])
for (j in 1:dlagdeg) {
  
  band1summaries[,j] <- band1temp %*% distlagfunc[,j]
  band2summaries[,j] <- band2temp %*% distlagfunc[,j]
  
}

fullcasemat$band1summaries <- band1summaries
fullcasemat$band2summaries <- band2summaries

# bring out your dead!!!!!!!!!!!!!!!!!!!!!!!!!
rm(band1summaries)
rm(band2summaries)
gc()

# include the mosquito summary statistic
stratayearmosq <- randeffs
stratayearmosq <- stratayearmosq[c("stratayear","mosqinfect")]
names(stratayearmosq) <- c("stratayear","MIRsummarystat")

# import county identifiers
fullcasemat <- merge(x=fullcasemat, y=strata,
                     by.x="county", by.y="county",
                     all.x=TRUE)
fullcasemat$year <- as.numeric(format(fullcasemat$weekstartdate, "%Y"))
fullcasemat$stratayear <- paste(fullcasemat$strata, fullcasemat$year, sep=":")
fullcasemat$year <- NULL

fullcasemat <- merge(x=fullcasemat, y=stratayearmosq,
                     by.x="stratayear", by.y="stratayear",
                     all.x=TRUE)

# calculate missing MIRsummarystat
stratayearmosq$strata <- substr(stratayearmosq$stratayear, 1, 3)
tempdf <- aggregate(stratayearmosq$MIRsummarystat,
                    by=list(stratayearmosq$strata),
                    FUN=mean,
                    na.rm=TRUE)
names(tempdf) <- c("strata","MIRsummarystat2")

fullcasemat <- merge(x=fullcasemat, y=tempdf,
                     by.x="strata", by.y="strata",
                     all.x=TRUE)
fullcasemat$MIRsummarystat[is.na(fullcasemat$MIRsummarystat)] <- fullcasemat$MIRsummarystat2[is.na(fullcasemat$MIRsummarystat)]

fullcasemat$strata <- NULL
fullcasemat$stratayear <- NULL
```

```{r humanreg, echo=FALSE, include=FALSE}

# get rid of counties that never have a positive case in the time period
fullcasemat$doy <- as.numeric(format(fullcasemat$weekstartdate, "%j"))
firstreg  <- glm(anycases ~ 0+MIRsummarystat+county+
                   band1summaries+
                   band2summaries+
                   band1summaries:doy+
                   band2summaries:doy,
                 family=binomial(), data=fullcasemat,
                 subset=observed==1)




# show predictions
preds <- predict(firstreg, type="link", newdata=fullcasemat, se.fit=TRUE)
fullcasemat$est <- predict(firstreg, type="response", newdata=fullcasemat)

preds <- as.matrix(cbind(preds$fit, preds$se.fit))
preds <- data.frame(preds)
names(preds) <- c("est", "sd")
preds$upper <- preds$est + 1.96*preds$sd
preds$lower <- preds$est - 1.96*preds$sd
preds$est   <- preds$est

preds$upper <- 1 / (1 + exp(-preds$upper))
preds$lower <- 1 / (1 + exp(-preds$lower))
preds$est <- 1 / (1 + exp(-preds$est))


tempfull <- fullcasemat
tempfull$preds <- preds$est

tempfull$month <- as.numeric(format(tempfull$weekstartdate, "%m"))
tempfull <- tempfull[which(tempfull$month >= 6),]
tempfull <- tempfull[which(tempfull$month <= 10),]

```

```{r humanregplot, echo=FALSE}
tempdf <- data.frame(weekstartdate=fullcasemat$weekstartdate,
                     obs=fullcasemat$anycases,
                     est=preds$est)
tempdf <- group_by(tempdf, weekstartdate)
tempdf <- dplyr::summarize(tempdf,
                    obs=mean(obs, na.rm=TRUE),
                    est=mean(est, na.rm=TRUE))
tempdf <- ungroup(tempdf)
tempdf2 <- tempdf
tempdf2$week <- as.numeric(format(tempdf2$weekstartdate, "%U"))
lowe <- 12
hiwe <- 52-12

tempdf2 <- tempdf2[tempdf2$week >= lowe,]
tempdf2 <- tempdf2[tempdf2$week <= hiwe,]

tempdf2$newwe <- (tempdf2$week - lowe) / (hiwe - lowe + 1)
tempdf2$year <- as.numeric(format(tempdf2$weekstartdate, "%Y"))
tempdf2$newdate <- tempdf2$year + tempdf2$newwe
```

```{r fig.width=7, fig.height=3.5, echo=FALSE, warnings=FALSE}
thisplot <- ggplot(tempdf2) + geom_line(aes(x=newdate,
                               y=obs)) +
  geom_line(aes(x=newdate, y=est), color="red") +
  ggtitle("Statewide model predictions") +
  xlab("") + ylab("") +
  scale_x_continuous(breaks=seq(from=minmosqyear,to=(maxmosqyear+1),by=1),
                     labels=c(seq(from=minmosqyear, to=maxmosqyear, by=1), ""),
                     limits=c((minmosqyear+0.125),(maxmosqyear+1))) +
  ylab("Proportion of counties positive") +
  theme(panel.grid.minor.x=element_blank()) +
  theme(axis.text.x = element_text(hjust=-0.225))
plot(thisplot)
```
```{r silentsave8879823, include=FALSE, echo=FALSE}
ggsave(paste(graphicoutputdir,
             "predictions.png",
             sep=""), thisplot)

```
```{r curyearplot, include=TRUE, echo=FALSE, fig.width=7, fig.height=3.5}

tempdf <- fullcasemat
tempdf <- group_by(tempdf, weekstartdate)
tempdf <- dplyr::summarize(tempdf,
                    obs=mean(anycases, na.rm=TRUE),
                    est=mean(est, na.rm=TRUE))
tempdf$year <- as.numeric(format(tempdf$weekstartdate, "%Y"))
tempdf$month <- as.numeric(format(tempdf$weekstartdate, "%m"))

tempdf <- tempdf[tempdf$month >= 5,]
tempdf <- tempdf[tempdf$month <= 11,]

thisyear <- tempdf[tempdf$year == maxmosqyear,]
comparison1 <- tempdf[tempdf$year == compyear1,]
comparison2 <- tempdf[tempdf$year == compyear2,]

comparison1$weekstartdate <- comparison1$weekstartdate + (maxmosqyear - compyear1)*365
comparison2$weekstartdate <- comparison2$weekstartdate + (maxmosqyear - compyear2)*365

tempdf <- bind_rows(thisyear,
                    comparison1,
                    comparison2)

tempdf$est[tempdf$year == compyear1] <- tempdf$obs[tempdf$year == compyear1]
tempdf$est[tempdf$year == compyear2] <- tempdf$obs[tempdf$year == compyear2]
tempdf$year <- factor(tempdf$year)

tempdf2 <- thisyear[thisyear$weekstartdate >= weekinquestionSun,]
tempdf2 <- tempdf2[1,]
```
Predictions for `r maxmosqyear` are compared to observations in `r compyear1` and `r compyear2`. We expect `r round(66*tempdf2$est,1)` counties to have at least one human case between `r weekinquestionSunstr` `r weekinquestionSun` and `r weekinquestionSatstr` `r weekinquestionSat`.

```{r plotblah, include=TRUE, echo=FALSE, fig.width=7, fig.height=3.5}
thisplot <- ggplot(tempdf) + geom_line(data=tempdf, aes(x=weekstartdate,
                           y=est,
                           color=year,
                           linetype=year)) +
  geom_point(data=tempdf2, aes(x=weekstartdate, y=est), color="red", size=4)+
  xlab("") + ylab("") +
  scale_x_date(date_labels="%b", date_breaks="1 month",
               limits=c(as.Date(paste(maxmosqyear, "-05-01", sep=""), "%Y-%m-%d"),
                        as.Date(paste(maxmosqyear, "-11-15", sep=""), "%Y-%m-%d")),
               labels=c("May","Jun","Jul","Aug","Sep","Oct","Nov","")) +
  ylab("Proportion of counties positive") +
  theme(panel.grid.minor.x=element_blank()) +
  scale_linetype_manual(values=c(3,2,1)) +
  scale_color_manual(values=c("black","black","red"))
thisplot1 <- thisplot + ggtitle(paste("Estimates for ",
                maxmosqyear, " compared to observations in ", compyear1, " and ", compyear2,
                "\nwith week beginning ", weekinquestionSun, " highlighted", sep="")) +
  theme(axis.text.x = element_text(hjust=-1.25))
plot(thisplot1)
```
```{r silentsave12899234, include=FALSE, echo=FALSE}
thisplot2 <- thisplot + theme(legend.position="bottom") +
  theme(axis.text.x = element_text(hjust=-0.50))
ggsave(paste(graphicoutputdir,
             "estimates.png",
             sep=""), thisplot2,
       width=4,
       height=4)

```

```{r echo=FALSE}
write.csv(x=fullcasemat[c("county","weekstartdate",
                          "anycases","totalcases", "est")],
          file=paste(fullcasematoutputdir, "case matrix.csv", sep=""))
fullcasemat$year <- as.numeric(format(fullcasemat$weekstartdate, "%Y"))
thisyear <- fullcasemat[fullcasemat$year == maxmosqyear,]
previousyears <- fullcasemat[fullcasemat$year < maxmosqyear,]
sumtotal <- sum(previousyears$totalcases, na.rm=TRUE)
sumany   <- sum(previousyears$anycases, na.rm=TRUE)

multiplier <- round(sumtotal / sumany, 2)
positivesthisyear <- round(sum(thisyear$est, na.rm=TRUE), 1)
casesthisyear     <- round(positivesthisyear * multiplier, 1)
```

We expect that there will be `r positivesthisyear` positive county-weeks this year. If we assume that each positive county-week corresponds to `r multiplier` cases, which is an estimate based on historical data, then this yields a total of `r casesthisyear` cases estimated for `r maxmosqyear`.

\newpage
## Results for `r weekinquestionSun` to `r format(weekinquestionSat, "%m-%d")`

We visualize the raw estimated risk for `r weekinquestion` below. If a county is darkest blue, then we estimate that there should be no human cases reported for this county, during this week. If a county is brightest red, we are certain that there will be at least one human case reported for this county, during this week.

```{r shapefile, include=FALSE, echo=FALSE, warnings=FALSE}
county_shapes <- readShapePoly(countyshapefile)
county_shapes$NAME <- simplifynames(county_shapes$NAME)
crs(county_shapes) <- "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80     +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
projected_counties <- spTransform(county_shapes, crs("+proj=longlat +datum=WGS84 +no_defs"))
projected_counties@data$id = rownames(projected_counties@data)
projected_counties.df <- tidy(projected_counties)
projected_counties.df <- left_join(projected_counties.df, projected_counties@data, by="id")
projected_counties.df$county <- simplifynames(projected_counties.df$NAME)

# get this week's predictions
thisweek <- fullcasemat[fullcasemat$weekstartdate >= weekinquestion,]
thisweek <- thisweek[thisweek$weekstartdate == min(thisweek$weekstartdate, na.rm=TRUE),]
thisweek <- thisweek[c("county", "est")]

projected_counties.df <- left_join(projected_counties.df, thisweek,
                                   by="county")
projected_counties.df$est[is.na(projected_counties.df$est)] <- min(projected_counties.df$est, na.rm=TRUE)
```
```{r shapefile2, include=TRUE, echo=FALSE, fig.width=7, fig.height=3.5}
thisplot <- ggplot(projected_counties.df) +
      aes(long,lat,fill=est,group=group,id=id,guides=FALSE) +
      geom_polygon() + xlab("") + ylab("") +
      geom_path(color="black") +
      theme(legend.position="bottom") +
      scale_fill_distiller(palette = "Spectral", limits=c(0,1),
                                                 breaks = c(0,1),
                                                 labels = c("Will definitely not\nreport any cases",
                                                            "Will definitely\nreport some cases"),
                                                     name = "") +
      coord_map() + ggtitle(paste("Estimate for week beginning ",
                            weekinquestionSun,
                            sep="")) +
        theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
            axis.ticks = element_blank(), axis.text.x = element_blank(),
            axis.text.y = element_blank(), axis.title.x=element_blank(),
            axis.title.y = element_blank(),
            legend.position="bottom",
            legend.key.width=unit(1, "cm"),
            legend.key.height=unit(0.25,"cm"))
plot(thisplot)
```
```{r silentsave89712, include=FALSE, echo=FALSE}
ggsave(paste(graphicoutputdir,
             "map absolute.png",
             sep=""), thisplot)
```

This map indicates whether probabilities reported in the previous map are higher (red) than average, lower (blue) than average, or right about normal (yellow) compared to the same week in previous years.

```{r riskcalcs, include=TRUE, echo=FALSE, fig.width=7, fig.height=3.5}
thisweek <- fullcasemat[fullcasemat$weekstartdate >= weekinquestion,]
thisweek <- thisweek[thisweek$weekstartdate == min(thisweek$weekstartdate, na.rm=TRUE),]
thisweek <- thisweek[c("county", "est", "doy")]

approxdoy <- thisweek$doy[1]

fullcasemat$year <- as.numeric(format(fullcasemat$weekstartdate, "%Y"))

doypreds <- data.frame()
for (curyear in unique(fullcasemat$year)) {
  
  for (curcounty in unique(fullcasemat$county)) {
    
    thisdf <- fullcasemat[fullcasemat$year == curyear,]
    thisdf <- thisdf[thisdf$county == curcounty,]
    
    tempdf <- data.frame(county = curcounty,
                         year = curyear,
                         est = approx(x=thisdf$doy,
                                      y=thisdf$est,
                                      xout=approxdoy)$y)
    
    doypreds <- bind_rows(doypreds, tempdf)
    
  }
  
}

doypreds2 <- data.frame()
for (curcounty in unique(doypreds$county)) {

  tempdf <- doypreds[doypreds$county == curcounty,]
  tempdf$percentile <- rank(tempdf$est, ties.method="random") / length(tempdf$est)
  
  doypreds2 <- bind_rows(doypreds2, tempdf)
  
}
doypreds <- doypreds2
rm(doypreds2)

riskalpha <- 0.25
doypreds$riskcategory <- " About average    "
doypreds$riskcategory[doypreds$percentile <= riskalpha/2] <- " Lower than usual    "
doypreds$riskcategory[doypreds$percentile >= 1-(riskalpha/2)] <- " Higher than usual    "
doypredscurrent <- doypreds[doypreds$year == as.numeric(format(weekinquestion, "%Y")),]
projected_counties.df <- left_join(projected_counties.df, doypredscurrent,
                                   by="county")
projected_counties.df$riskcategory[is.na(projected_counties.df$riskcategory)] <- " Not able to model    "
thisplotrisk <- ggplot(projected_counties.df) +
      aes(long,lat,fill=riskcategory,group=group,guides=FALSE) +
      geom_polygon() + 
      geom_path(color="black") +
      coord_map() + 
      ggtitle("") +
      theme(text=element_text(size=15)) +
      theme(plot.title=element_text(size=15),
            legend.key=element_rect(fill="white")) +
      theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
            axis.ticks = element_blank(), axis.text.x = element_blank(),
            axis.text.y = element_blank(), axis.title.x=element_blank(),
            axis.title.y = element_blank(),
            legend.position="bottom",
            legend.key.width=unit(1, "cm"),
            legend.key.height=unit(0.5,"cm")) +
      theme(legend.direction="vertical") +
      scale_fill_manual(name=paste("Risk for ", weekinquestionSun, " to ",
                                   format(weekinquestionSat, "%m-%d"), sep=""),
                        values=c(" Lower than usual    "="lightblue",
                                 " About average    "="yellow",
                                 " Higher than usual    "="red",
                                 " Not able to model    "="grey"))


plot(thisplotrisk)
```
```{r silentsave1245, include=FALSE, echo=FALSE}
ggsave(paste(graphicoutputdir,
             "map relative.png",
             sep=""), thisplotrisk,
       width=4,
       height=4)

sitegraphic <- grid.arrange(thisplotrisk +
                            theme(legend.position="right",
                                  legend.direction="vertical") +
                            scale_fill_manual(name="Risk this week",
                            values=c(" Lower than usual    "="lightblue",
                                     " About average    "="yellow",
                                     " Higher than usual    "="red",
                                     " Not able to model    "="grey")) +
                            #ylab("hidden axis") +
                            #theme(axis.title.y = element_text(colour = "white")) +
                            theme(legend.key.width=unit(0.25, "cm"),
                            legend.key.height=unit(0.50,"cm"),
                            text=element_text(size=10)) + 
                            theme(plot.margin = unit(c(0,0,0,0.4), "cm")),
  
                            # t r b l
                            
                            thisplot2 +
                            theme(legend.position="right") + ylab("") +
                            theme(axis.text.x=element_text(family="mono"))+
                            theme(panel.grid.minor=element_blank(),
                                  axis.text.y=element_blank(),
                                  axis.ticks=element_blank())+
                            theme(axis.text.x = element_text(hjust=-0.35)) +
                            theme(plot.margin = unit(c(0.1,0.2,0.1,-0.1), "cm")), nrow=2) 

ggsave(paste(graphicoutputdir,
             "site graphic.png",
             sep=""), sitegraphic,
       width=4,
       height=4)

```





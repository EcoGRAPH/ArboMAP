---
output: pdf_document
---

# Appendix

## Forecast results

### Additional model fit statistics

```{r appx_model_fit, echo=FALSE, include=TRUE}

#Creates a table of expanded model fit statistics BY model

#calculate additional model evaluation metrics
#temporal and spatial MAEs
#borrowed from validation paper code and adapted [DMN]

eval_mae_temporal <- preds %>% 
  #ONLY EVAL MODELLED WEEKS
  filter(modeled == 1) %>% 
  #no spatial/district
  group_by(model, year_epi, week_epi) %>% 
  dplyr::summarize(sum_any_cases = sum(any_cases, na.rm = TRUE),
                   sum_pred = sum(pred, na.rm = TRUE),
                   .groups = "drop") %>% 
  mutate(abs_err = abs(sum_any_cases - sum_pred)) %>% 
  #mean of all weeks
  group_by(model) %>% 
  dplyr::summarize(mae_temporal = mean(abs_err, na.rm = TRUE))

#spatial
eval_mae_spatial <- preds %>% 
  #ONLY EVAL MODELLED WEEKS
  filter(modeled == 1) %>% 
  #spatial/district (NOT by week)
  group_by(model, year_epi, arbo_ID) %>% 
  dplyr::summarize(sum_any_cases = sum(any_cases, na.rm = TRUE),
                   sum_pred = sum(pred, na.rm = TRUE),
                   .groups = "drop") %>% 
  mutate(abs_err = abs(sum_any_cases - sum_pred)) %>% 
  #mean of all districts
  group_by(model) %>% 
  dplyr::summarize(mae_spatial = mean(abs_err, na.rm = TRUE))

#join together
model_evals_extra <- model_evals %>% 
  left_join(eval_mae_temporal, by = c("model")) %>% 
  left_join(eval_mae_spatial, by = c("model")) %>% 
  dplyr::select(model, everything())

if (model_evaluation | dev_write_output){
  readr::write_csv(
    model_evals_extra, 
    file = file.path("..", out_folder, paste0(out_name_base, "__modeleval.csv")))
}

knitr::kable(model_evals_extra %>% 
               dplyr::select(model, auc, aic, mae_temporal, mae_spatial),
             col.names = c("Model", "AUC", "AIC", "MAE Temporal", "MAE Spatial"),
             digits = c(0, 3, 0, 3, 3),
             align = "c",
             caption = "Fit statistcs by model")
```


### Current-week WNV relative risk maps

```{r appx_rel_risk_map, echo=FALSE, include=TRUE, fig.align='center', out.width="100%", results='asis'}

# V4 algorithm
# For each model:
# 1. For each district-year, get the pred value at the same EPI WEEK as the forecast week
# 2. RANK these pred values and divide by the number of years of values each district has.
#     This creates a ~percentile of RANKED risk (basically)
# 3. Percentile values kept as continuous to match style of absolute risk maps
#     [V3]: <= 12.5% lower than ave, => 87.5% higher than ave
#     Will need to indicate something similar in legend
# 4. Map each model
# Note: This is therefore the relative risk of PREDICTED values. 
#     May want to consider if there is some way to compare forecast-week predicted value
#       against OBSERVED historical values (any_cases), but not certain how that 
#       mathematically would work out (as any_cases is {0|1}). [DMN]

#rank the specific week's pred against the other years
appx_rel_risk <- preds %>% 
  #get all preds at same epiweek (in any year)
  dplyr::filter(week_epi == epiweek_request) %>% 
  # rank within each district & model
  dplyr::group_by(arbo_ID,
                  model) %>% 
  dplyr::mutate(rank_pred = rank(pred, ties.method = 'random'),
                #percentile of ranked pred by number of years
                # note: rank such that lowest pred = 1
                rank_perc = rank_pred / n() * 100) %>% 
  #and get this current-year week
  dplyr::filter(year_epi == epiyear_request) %>% 
  #ungroup to finish
  dplyr::ungroup()

#same breaks as [V3]
lower_risk <- 12.5
higher_risk <- 87.5

#loop for each model
for (i in seq_along(model_names)){
  
  #this model
  this_model <- model_names[i]
  this_model_desc <- model_desc_names[[this_model]]
  this_rel_risk <- appx_rel_risk %>% 
    dplyr::filter(model == this_model)
  
  #title section
  this_model_title <- paste0(this_model_desc, ": \"", this_model, "\"")
  #note needs results='asis' in code block header
  cat("#### ", this_model_title)
  
  #this model's data joined with spatial
  this_sf_rel_risk <- data_sf_orig %>% 
    dplyr::left_join(this_rel_risk,
                     by = "arbo_ID")
  
  #this model's plot
  this_p_rel_risk <- ggplot2::ggplot() +
    #by rank percentile
    ggplot2::geom_sf(data = this_sf_rel_risk,
                     aes(fill = rank_perc)) +
    viridis::scale_fill_viridis("", 
                                #limits always 0 - 100
                                limits = c(0, 100),
                                #using [V3] breaks
                                breaks = c(0, lower_risk, 50, higher_risk, 100),
                                labels = c("0",
                                           paste(lower_risk, ": Lower than average risk"),
                                           "50: Average risk",
                                           paste(higher_risk, ": Higher than average risk"),
                                           "100")) +
    ggtitle("Risk in forecast week relative to the same epiweek in previous years",
            subtitle = this_model_title) +
    theme_arbo_map
  
  plot(this_p_rel_risk)
  
  #this model's table 
  #Table of counties with higher than average risk
  this_kable <- knitr::kable(
    rel_risk %>% 
      dplyr::filter(pred_ave >= higher_risk) %>% 
      #join with crosswalk to get pretty names
      dplyr::left_join(id_crosswalk, by = "arbo_ID") %>% 
      dplyr::select(NAME, pred_ave),
    col.names = c("County", "Risk"),
    digits = 2,
    align = c("l", "c"),
    caption = "Counties with higher than average risk")
  
  #note to get kable in a for loop, you must 
  # print kable with cat extra line WITH results='asis' in header
  #https://github.com/yihui/knitr/issues/886
  print(this_kable)
  cat("\n")
}

```

### Current-week WNV absolute risk maps

```{r appx_abs_risk_map, echo=FALSE, include=TRUE, fig.align='center', out.width="100%", results="asis"}

# Creates a map of absolute risk of the requested forecast week
# for each model

appx_preds_fc_wk <- preds %>% 
  dplyr::filter(year_epi == epiyear_request & week_epi == epiweek_request)


#loop for each model
for (i in seq_along(model_names)){
  
  #this model
  this_model <- model_names[i]
  this_model_desc <- model_desc_names[[this_model]]
  this_abs_risk <- appx_preds_fc_wk %>% 
    dplyr::filter(model == this_model)
  
  #title section
  this_model_title <- paste0(this_model_desc, ": \"", this_model, "\"")
  #note needs results='asis' in code block header
  cat("#### ", this_model_title)
  
  
  #join with spatial
  this_sf_abs_risk <- data_sf_orig %>% 
    dplyr::left_join(this_abs_risk, by = "arbo_ID")
  
  this_p_abs_risk <- ggplot2::ggplot() +
    ggplot2::geom_sf(data = this_sf_abs_risk,
                     aes(fill = pred)) +
    viridis::scale_fill_viridis("", 
                                #limits always 0 - 1
                                limits = c(0, 1),
                                breaks = c(0, 1),
                                labels = c("0: Less likely\nto report any cases", 
                                           "1: More likely\nto report at least one case")) +
    ggtitle("Absolute risk in forecast week",
            subtitle = this_model_title) +
    theme_arbo_map
  
  plot(this_p_abs_risk)
}

```


### Current-year forecasts

```{r appx_curyr_forecast, echo=FALSE, include=TRUE, fig.align='center', out.width="100%"}

#Creates an epicurve of the current forecast year PREDICTIONS
# EACH model, no ribbon (as compared to average version in main report)
# Adds the HISTORICAL human epicurve 

# [DEV] Note that human summary data is on a different scale
#   than forecast, and ggplot2 does NOT allow for 2 different x-axes
# Rescaled by using the average historical proportion positive
#   as opposed to the [V3] count of districts positive


## Statewide predictions
appx_preds_st <- preds %>% 
  #not grouping by arbo_ID here
  dplyr::group_by(model, 
                  #keeping all date-related fields, 
                  # need to at least group on date_epi (or year+week)
                  date_epi, week_epi, year_epi, doy) %>% 
  dplyr::summarise(pred_ave = mean(pred, na.rm = TRUE),
                   mean_any_cases = mean(any_cases, na.rm = TRUE),
                   tot_case_count = sum(case_count, na.rm = TRUE), 
                   .groups = 'drop') %>% 
  #split into two series : pre & post fc_week - for graphing with two different styles
  #intentionally having fc week be both pre and post, so lines appear connected
  dplyr::mutate(pred_pre = dplyr::if_else(year_epi < epiyear_request, #previous years
                                          pred_ave,
                                          NA_real_),
                #earlier in forecast yr, update 
                pred_pre = dplyr::if_else(week_epi <= epiweek_request & 
                                            year_epi == epiyear_request, 
                                          pred_ave,
                                          pred_pre),
                pred_post = dplyr::if_else(week_epi >= epiweek_request & 
                                             year_epi == epiyear_request,
                                           pred_ave,
                                           NA_real_)) %>% 
  #censored to modelled range (with buffer)
  dplyr::filter(week_epi >= (human_wk_min - 1) &
                  week_epi <= (human_wk_max + 1))

appx_preds_curyr <- appx_preds_st %>% 
  #only forecast year
  dplyr::filter(year_epi == epiyear_request)

#human data already set up in main report
# keeping separate to graph, since separate from model type
#data_human_st_prop 

#pivot predictions long for ggplot
appx_preds_curyr_long <- appx_preds_curyr %>% 
  dplyr::select(week_epi, model, pred_pre, pred_post) %>% 
  tidyr::pivot_longer(cols = c(pred_pre,
                               pred_post),
                      names_to = "series",
                      values_to = "stat_value") %>% 
  #change order in legend
  dplyr::mutate(series = factor(series, levels = c("pred_pre", "pred_post")))

#Current year forecast plot
appx_p_cur_yr <- ggplot2::ggplot() +
  #human line
  geom_line(data = data_human_st_prop %>% 
              #censored to modelled range (with buffer)
              dplyr::filter(week_epi >= (human_wk_min - 1) &
                              week_epi <= (human_wk_max + 1)),
            aes(x = week_epi,
                y = pp_mean,
                #alpha to trick into creating a legend
                #only works b/c using default, a black solid line
                alpha = "human"),
            color = "black",
            linetype = "solid") +
  #per model predictions
  geom_line(data = appx_preds_curyr_long,
            aes(x = week_epi,
                y = stat_value,
                linetype = series,
                color = model)) +
  #current week marker
  geom_vline(xintercept = epiweek_request, linetype = "dashed", color = "grey25") +
  #plot labels and adjustments
  #for model colors
  scale_color_viridis("Model", option = "turbo", discrete = TRUE) +
  #for pre/post forecast week
  scale_linetype_manual("Time linetype indicator",
                        values = c("pred_pre" = "solid",
                                   "pred_post" = 22), #22 is tight dashed
                        labels = c("pred_pre" = "Past model forecast",
                                   "pred_post" = "Future model forecast")) +
  #for tricking into human legend
  scale_alpha_manual("", 
                     values = c("human" = 1),
                     labels = c("human" = "Historical\naverage proportion")) +
  ggtitle(paste("Statewide model predictions in", epiyear_request, 
                "at forecast epiweek", epiweek_request)) +
  #change order of legends
  guides(
    color = guide_legend(order = 1),
    linetype = guide_legend(order = 2),
    alpha = guide_legend(order = 3)) +
  #[V3] How y-axis labeled in v3, keeping same [DMN]
  ylab("Proportion of districts positive") + 
  xlab("Epiweek") +
  theme_arbo_chart 

plot(appx_p_cur_yr)

```


### Case estimations

```{r appx_pos_to_cases, echo=FALSE, include=TRUE}

#Estimates number of cases from positive district-weeks
# Splits out previous yearly summaries to model
#   and predicts on current year

#Uses pred_yrs_fc_yr created in main report, just before summarizing across models

#create table to display
knitr::kable(pred_yrs_fc_yr %>%
               dplyr::select(year_epi, model,
                             tot_pred, tot_pred_cases),
             col.names = c("Year", "Model",
                           "Predicted positive district-weeks", "Estimated cases"),
             digits = c(1,0), 
             align = c("l", "l", "c", "c"),
             caption = "Estimated number of WNV cases")


```


\blandscape
### Multi-year forecasts

```{r appx_multiyr_forecast, echo=FALSE, include=TRUE, fig.align='center', fig.width=10}

#Creates a multi-year time series chart of the predicted per model vs. 
#   observed positive district-weeks


appx_multiyr <- appx_preds_st %>% #from appx cur yr code block
  #update mean_any_cases to be NA during forecast year
  dplyr::mutate(mean_any_cases = dplyr::if_else(year_epi == epiyear_request,
                                                NA_real_,
                                                mean_any_cases)) %>% 
  #modified date to deal with skipping weeks between seasons
  # borrowed from [V3]
  # year + decimal fraction [DMN]
  dplyr::mutate(modwk = (week_epi - human_wk_min) / (human_wk_max - human_wk_min + 1),
                moddate = year_epi + modwk)

#for model forecasts
appx_multiyr_long <- appx_multiyr %>% 
  #pull needed and pivot long
  dplyr::select(model, moddate, 
                pred_pre, pred_post) %>% 
  tidyr::pivot_longer(cols = c(pred_pre, pred_post),
                      names_to = "series",
                      values_to = "value")

#for human data, using mean of any cases: appx_multiyr$mean_any_cases
#   i.e. NOT the same as current year graphs, which use ave by week of year of all years

appx_p_multiyr <- ggplot() +
  #historical any cases (observed)
  geom_line(data = appx_multiyr,
            aes(x = moddate,
                y = mean_any_cases,
                #alpha to trick into creating a legend
                #only works b/c using default, a black solid line
                alpha = "human"),
            color = "black",
            linetype = "solid") +
  #per model predictions
  geom_line(data = appx_multiyr_long,
            aes(x = moddate,
                y = value,
                linetype = series,
                color = model)) +
  #plot labels and adjustments
  #for model colors
  scale_color_viridis("Model", option = "turbo", discrete = TRUE) +
  #for pre/post forecast week
  scale_linetype_manual("Time linetype indicator",
                        values = c("pred_pre" = "solid",
                                   "pred_post" = 22), #22 is tight dashed
                        labels = c("pred_pre" = "Past model forecast",
                                   "pred_post" = "Future model forecast")) +
  #for tricking into human legend
  scale_alpha_manual("", 
                     values = c("human" = 1),
                     labels = c("human" = "Observed")) +
  #x-axis management to only show the modeled weeks per year 
  #   borrowed heavily from [V3]
  scale_x_continuous(breaks = seq(from = params$year_human_start + 0.5,
                                  to = (params$year_human_end + 1.5),
                                  by = 1),
                     labels = seq(from = params$year_human_start, 
                                  to = params$year_human_end + 1, 
                                  by = 1),
                     limits = c((params$year_human_start),
                                (params$year_human_end + 2))) +
  ggtitle(paste("Statewide model predictions")) + 
  #change order of legends
  guides(
    color = guide_legend(order = 1),
    linetype = guide_legend(order = 2),
    alpha = guide_legend(order = 3)) +
  #[V3] How y-axis labeled in v3, keeping same [DMN]
  ylab("Proportion of districts positive") + 
  theme_arbo_chart +
  theme(legend.position="bottom", 
        #legend gets cut off so multiple rows across various aesthetics
        legend.box = "vertical", 
        legend.direction = "horizontal", 
        #compact
        legend.margin = margin(),
        legend.key.height = unit(0.15, 'in'))


plot(appx_p_multiyr)

```

\elandscape

### <<Estimated dependence functions>>

## Data summaries

### Anomalized environmental variables

```{r appx_anom_weather, echo=FALSE, include=TRUE, fig.align='center', out.width="100%", fig.height=c(3,6)}

#Create environmental data plots for the current year 
#   with historical doy information in background
# [V3] used medians, so retained in [V4]

#Note on tidyverse dynamic names
# We have to tell it to evaluate the variable that is the name of the variable
  #  by using !!sym() (or {{}} if it worked), 
  #  and if that's on the LHS, use := instead of =

# historical data - state-wide 
#   as opposed to by district data_env_hx
appx_data_env_doy <- data_env %>% 
  #summarize to state
  dplyr::group_by(doy) %>% 
  dplyr::summarise(            
    #medians
    !!rlang::sym(paste0(var1_anom_name, 
                        "_med")) := quantile(!!rlang::sym(var1_anom_name),
                                             probs = 0.5, na.rm = TRUE),
    !!rlang::sym(paste0(var2_anom_name,
                        "_med")) := quantile(!!rlang::sym(var2_anom_name),
                                             probs = 0.5, na.rm = TRUE),
    #mins
    !!rlang::sym(paste0(var1_anom_name, 
                        "_min")) := min(!!rlang::sym(var1_anom_name),
                                        na.rm = TRUE),
    !!rlang::sym(paste0(var2_anom_name,
                        "_min")) := min(!!rlang::sym(var2_anom_name),
                                        na.rm = TRUE),
    #maxs
    !!rlang::sym(paste0(var1_anom_name, 
                        "_max")) := max(!!rlang::sym(var1_anom_name),
                                        na.rm = TRUE),
    !!rlang::sym(paste0(var2_anom_name,
                        "_max")) := max(!!rlang::sym(var2_anom_name),
                                        na.rm = TRUE))

# this year data - state-wide
appx_data_env_fc_yr <- data_env %>% 
  dplyr::filter(year_epi == epiyear_request) %>% 
  #summarize to state using medians
  dplyr::group_by(doy) %>% 
  dplyr::summarise(            
    !!rlang::sym(paste0(var1_anom_name, 
                        "_med_yr")) := quantile(!!rlang::sym(var1_anom_name),
                                                probs = 0.5, na.rm = TRUE),
    !!rlang::sym(paste0(var2_anom_name,
                        "_med_yr")) := quantile(!!rlang::sym(var2_anom_name),
                                                probs = 0.5, na.rm = TRUE))

if (dev_write_output){
  #note folder modification since in rmd_sections subfolder
  readr::write_csv(appx_data_env_doy, file = file.path("..", out_folder, paste0(out_name_base, "_appx_data_env_appx_doy.csv")))
  readr::write_csv(appx_data_env_fc_yr, file = file.path("..", out_folder, paste0(out_name_base, "_appx_data_env_fc_appx_yr.csv")))
}

#segment line for showing color above/below median
env_comp_colors <- c("Higher" = "red",
                     "Crosses" = "mediumpurple4",
                     "Lower" = "blue3",
                     "Historical median" = "gray20")

#pasted median names for ease
var1_anom_med_name <- paste0(var1_anom_name, "_med")
var2_anom_med_name <- paste0(var2_anom_name, "_med")

appx_data_env_colors <- appx_data_env_fc_yr %>% 
  dplyr::left_join(appx_data_env_doy %>% 
                     dplyr::select(doy, ends_with("_med")),
                   by = "doy") %>% 
  #line segments are drawn x to xend, y to yend
  # going to do day by day: x segments are doy to doy+1
  #   y segments are value + lead(1) value
  dplyr::mutate(var_x = doy, 
                var_xend = dplyr::lead(var_x, n = 1),
                var1_y = !!rlang::sym(paste0(var1_anom_med_name, "_yr")),
                var1_yend = dplyr::lead(var1_y, n = 1),
                var2_y =  !!rlang::sym(paste0(var2_anom_med_name, "_yr")),
                var2_yend = dplyr::lead(var2_y, n = 1)) %>% 
  #now flag if y - yend is above, below, or crosses historical median
  dplyr::mutate(
    #var1
    color_var1 = case_when(
      var1_y >= !!rlang::sym(var1_anom_med_name) & 
        var1_yend >= !!rlang::sym(var1_anom_med_name) ~ "Higher",
      var1_y >= !!rlang::sym(var1_anom_med_name) & 
        var1_yend <= !!rlang::sym(var1_anom_med_name) ~ "Crosses",
      var1_y <= !!rlang::sym(var1_anom_med_name) & 
        var1_yend >= !!rlang::sym(var1_anom_med_name) ~ "Crosses",
      var1_y <= !!rlang::sym(var1_anom_med_name) & 
        var1_yend <= !!rlang::sym(var1_anom_med_name) ~ "Lower",
      TRUE ~ "forgotsomething"),
    #var2
    color_var2 = case_when(
      var2_y >= !!rlang::sym(var2_anom_med_name) & 
        var2_yend >= !!rlang::sym(var2_anom_med_name) ~ "Higher",
      var2_y >= !!rlang::sym(var2_anom_med_name) & 
        var2_yend <= !!rlang::sym(var2_anom_med_name) ~ "Crosses",
      var2_y <= !!rlang::sym(var2_anom_med_name) & 
        var2_yend >= !!rlang::sym(var2_anom_med_name) ~ "Crosses",
      var2_y <= !!rlang::sym(var2_anom_med_name) & 
        var2_yend <= !!rlang::sym(var2_anom_med_name) ~ "Lower",
      TRUE ~ "forgotsomething")) %>% 
  #lead(1) does not exist for last day in environmental data, so removing improper last entry
  dplyr::filter(!doy == max(data_env_fc_yr))

#plot
appx_p_env_var1_color <- ggplot() + 
  # min/max ribbon using wide data
  geom_ribbon(data = appx_data_env_doy, 
              aes(x = doy, 
                  ymin = !!rlang::sym(paste0(var1_anom_name, "_min")), 
                  ymax = !!rlang::sym(paste0(var1_anom_name, "_max")),
                  fill = "minmax")) +
  #historical median series
  geom_line(data = appx_data_env_colors,
            aes(x = doy, 
                y = !!rlang::sym(var1_anom_med_name),
                color = "Historical median")) +
  #line segment for year median with different colors
  geom_segment(data = appx_data_env_colors,
               aes(x = var_x, xend = var_xend,
                   y = var1_y, yend = var1_yend,
                   color = color_var1),
               size = 1) +
  #vertical line at the doy of requested date #linetype inside of aes to trigger legend
  geom_vline(aes(xintercept = doy_dt_epiwk_req, linetype = "forecast_doy"), color = "grey50") +
  #scales
  scale_fill_manual("",
                    values = c("minmax" = "grey80"),
                    labels = "Range over all years") +
  scale_linetype_manual("",
                        values = c("forecast_doy" = "dashed"),
                        labels = paste0("Day of year of requested\nforecast date: ", doy_dt_epiwk_req)) +
  scale_color_manual("Year median compared to historical median", 
                     values = env_comp_colors) +
  xlab("Day of the year") + 
  ylab(params$predictor_var1) +
  ggtitle(paste("Environmental data for anomalized", params$predictor_var1, 
                "in", max(data_env$year_epi, na.rm=TRUE))) +
  theme_arbo_chart +
  theme(legend.position = "none") #displayed in second chart

#plot
appx_p_env_var2_color <- ggplot() + 
  # min/max ribbon using wide data
  geom_ribbon(data = appx_data_env_doy, 
              aes(x = doy, 
                  ymin = !!rlang::sym(paste0(var2_anom_name, "_min")), 
                  ymax = !!rlang::sym(paste0(var2_anom_name, "_max")),
                  fill = "minmax")) +
  #historical median series
  geom_line(data = appx_data_env_colors,
            aes(x = doy, 
                y = !!rlang::sym(var2_anom_med_name),
                color = "Historical median")) +
  #line segment for year median with different colors
  geom_segment(data = appx_data_env_colors,
               aes(x = var_x, xend = var_xend,
                   y = var2_y, yend = var2_yend,
                   color = color_var2),
               size = 1) +
  #vertical line at the doy of requested date #linetype inside of aes to trigger legend
  geom_vline(aes(xintercept = doy_dt_epiwk_req, linetype = "forecast_doy"), color = "grey50") +
  #scales
  scale_fill_manual("",
                    values = c("minmax" = "grey80"),
                    labels = "Range over all years") +
  scale_linetype_manual("",
                        values = c("forecast_doy" = "dashed"),
                        labels = paste0("Day of year of requested\nforecast date: ", doy_dt_epiwk_req)) +
  scale_color_manual("Year median compared to historical median", 
                     values = env_comp_colors) +
  xlab("Day of the year") + 
  ylab(params$predictor_var2) +
  ggtitle(paste("Environmental data for anomalized", params$predictor_var2, 
                "in", max(data_env$year_epi, na.rm=TRUE))) +
  theme_arbo_chart +
  theme(legend.position="bottom", 
        #legend gets cut off so multiple rows across various aesthetics
        legend.box="horizontal", 
        legend.direction = "vertical",
        #compact
        legend.margin = margin(),
        legend.key.height = unit(0.15, 'in')) +
  #changing order of legend
  guides(
    color = guide_legend(order = 1),
    linetype = guide_legend(order = 3),
    fill = guide_legend(order = 2))

plot(appx_p_env_var1_color)
plot(appx_p_env_var2_color)
```






